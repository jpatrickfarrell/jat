/**
 * Task Summary API Endpoint
 *
 * GET /api/tasks/{id}/summary - Generates or retrieves a task completion summary
 *
 * The summary is generated by:
 * 1. Fetching signal data from .beads/signals/{taskId}.jsonl
 * 2. Fetching task data from Beads
 * 3. Calling Claude Haiku to generate a structured summary
 *
 * Summary is cached in .beads/summaries/{taskId}.json after generation.
 */

import { json } from '@sveltejs/kit';
import { readFile, writeFile, mkdir, access } from 'fs/promises';
import { join, resolve } from 'path';
import { execSync } from 'child_process';
import type { RequestHandler } from './$types';
import { getProjectPath } from '$lib/utils/projectUtils';
import Anthropic from '@anthropic-ai/sdk';
import { claudeCliCall } from '$lib/server/claudeCli';

interface TimelineEvent {
	type: string;
	state?: string;
	session_id: string;
	tmux_session: string;
	timestamp: string;
	task_id?: string;
	data?: Record<string, unknown>;
	git_sha?: string;
	agent_name?: string;
}

interface TaskSummary {
	taskId: string;
	title: string;
	summary: string[];
	outcome: 'completed' | 'incomplete' | 'blocked';
	duration?: string;
	agent?: string;
	keyChanges: string[];
	quality?: {
		tests?: string;
		build?: string;
	};
	suggestedTasks?: Array<{
		type: string;
		title: string;
		description: string;
		priority: number;
	}>;
	humanActions?: Array<{
		title: string;
		description: string;
	}>;
	crossAgentIntel?: {
		files?: string[];
		patterns?: string[];
		gotchas?: string[];
	};
	riskLevel?: 'low' | 'medium' | 'high';
	breakingChanges?: string[];
	generatedAt: string;
}

export const GET: RequestHandler = async ({ params, url }) => {
	const { id } = params;
	const regenerate = url.searchParams.get('regenerate') === 'true';

	if (!id) {
		return json({ error: 'Task ID is required' }, { status: 400 });
	}

	try {
		const projectRoot = getProjectPath(id) || resolve(process.cwd(), '..');
		const summariesDir = join(projectRoot, '.beads', 'summaries');
		const summaryFile = join(summariesDir, `${id}.json`);

		// Check for cached summary (unless regenerate is requested)
		if (!regenerate) {
			try {
				await access(summaryFile);
				const cached = await readFile(summaryFile, 'utf-8');
				const summary = JSON.parse(cached) as TaskSummary;
				return json({
					task_id: id,
					summary,
					cached: true,
					timestamp: new Date().toISOString()
				});
			} catch {
				// No cached summary, generate one
			}
		}

		// Fetch task data from Beads
		let taskData: { title: string; description: string; status: string; priority: number; issue_type: string; assignee?: string } | null = null;
		try {
			const taskJson = execSync(`cd "${projectRoot}" && bd show "${id}" --json`, { encoding: 'utf-8' });
			const tasks = JSON.parse(taskJson);
			if (tasks && tasks.length > 0) {
				taskData = {
					title: tasks[0].title || 'Unknown',
					description: tasks[0].description || '',
					status: tasks[0].status || 'unknown',
					priority: tasks[0].priority ?? 2,
					issue_type: tasks[0].issue_type || 'task',
					assignee: tasks[0].assignee
				};
			}
		} catch (err) {
			console.error('Failed to fetch task from Beads:', err);
		}

		if (!taskData) {
			return json({
				error: 'Task not found',
				message: `Could not find task ${id} in Beads`
			}, { status: 404 });
		}

		// Fetch signal data
		const signalsDir = join(projectRoot, '.beads', 'signals');
		const signalFile = join(signalsDir, `${id}.jsonl`);
		let signals: TimelineEvent[] = [];

		try {
			await access(signalFile);
			const content = await readFile(signalFile, 'utf-8');
			const lines = content.trim().split('\n').filter(line => line.trim());

			for (const line of lines) {
				try {
					const event = JSON.parse(line) as TimelineEvent;
					signals.push(event);
				} catch {
					// Skip malformed lines
				}
			}

			signals.sort((a, b) =>
				new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
			);
		} catch {
			// No signals for this task
		}

		// Extract relevant data from signals
		const startTime = signals[0]?.timestamp;
		const endTime = signals[signals.length - 1]?.timestamp;
		const agent = signals.find(s => s.agent_name)?.agent_name;
		const completedSignal = signals.find(s => s.state === 'completed' || s.type === 'complete');
		const hasCompletion = !!completedSignal;

		// Calculate duration
		let duration: string | undefined;
		if (startTime && endTime) {
			const start = new Date(startTime);
			const end = new Date(endTime);
			const diffMs = end.getTime() - start.getTime();
			const diffMins = Math.floor(diffMs / 60000);
			if (diffMins < 60) {
				duration = `${diffMins} minutes`;
			} else {
				const hours = Math.floor(diffMins / 60);
				const mins = diffMins % 60;
				duration = mins > 0 ? `${hours}h ${mins}m` : `${hours} hours`;
			}
		}

		// Extract completion data if available
		let completionData: Record<string, unknown> | undefined;
		if (completedSignal?.data) {
			completionData = completedSignal.data;
		}

		// If we have completion data with a summary, use it directly
		if (completionData?.summary && Array.isArray(completionData.summary)) {
			const crossAgentIntel = completionData.crossAgentIntel as { files?: string[]; patterns?: string[]; gotchas?: string[] } | undefined;
			const summary: TaskSummary = {
				taskId: id,
				title: taskData.title,
				summary: completionData.summary as string[],
				outcome: hasCompletion ? 'completed' : (taskData.status === 'blocked' ? 'blocked' : 'incomplete'),
				duration,
				agent,
				keyChanges: crossAgentIntel?.files || [],
				quality: completionData.quality as { tests?: string; build?: string } | undefined,
				suggestedTasks: completionData.suggestedTasks as TaskSummary['suggestedTasks'],
				humanActions: completionData.humanActions as TaskSummary['humanActions'],
				crossAgentIntel: crossAgentIntel ? {
					files: crossAgentIntel.files,
					patterns: crossAgentIntel.patterns,
					gotchas: crossAgentIntel.gotchas
				} : undefined,
				riskLevel: completionData.riskLevel as 'low' | 'medium' | 'high' | undefined,
				breakingChanges: completionData.breakingChanges as string[] | undefined,
				generatedAt: new Date().toISOString()
			};

			// Cache the summary
			await mkdir(summariesDir, { recursive: true });
			await writeFile(summaryFile, JSON.stringify(summary, null, 2));

			return json({
				task_id: id,
				summary,
				cached: false,
				source: 'completion_signal',
				timestamp: new Date().toISOString()
			});
		}

		// Build context for LLM
		const signalSummary = signals.map(s => {
			const state = s.state || s.type;
			const time = new Date(s.timestamp).toLocaleTimeString();
			return `${time}: ${state}${s.agent_name ? ` (${s.agent_name})` : ''}`;
		}).join('\n');

		const prompt = `Generate a completion summary for this task. Output ONLY valid JSON, no markdown.

## Task Information
- Task ID: ${id}
- Title: ${taskData.title}
- Type: ${taskData.issue_type}
- Priority: P${taskData.priority}
- Status: ${taskData.status}
- Description: ${taskData.description || 'No description'}

## Signal Timeline
${signalSummary || 'No signals recorded'}

## Duration
${duration || 'Unknown'}

## Agent
${agent || 'Unknown'}

Generate a JSON object with:
{
  "taskId": "${id}",
  "title": "${taskData.title}",
  "summary": ["2-4 bullet points describing what was accomplished based on the task title and description"],
  "outcome": "completed" | "incomplete" | "blocked",
  "keyChanges": ["key files or areas that were likely modified based on the task"],
  "quality": { "tests": "passing|failing|none", "build": "clean|warnings|errors" },
  "suggestedTasks": [
    {
      "type": "task|bug|feature|chore",
      "title": "Short descriptive title",
      "description": "What needs to be done and why",
      "priority": 2
    }
  ],
  "crossAgentIntel": {
    "patterns": ["useful patterns discovered"],
    "gotchas": ["things to watch out for"]
  }
}

For suggestedTasks: Include 0-3 follow-up tasks if the work naturally leads to additional improvements, tests, documentation, or related features. Leave empty array if the task is self-contained.

Output ONLY the JSON object.`;

		// Try to generate summary using LLM (API key or CLI fallback)
		const apiKey = process.env.ANTHROPIC_API_KEY;

		try {
			let responseText: string;

			if (apiKey) {
				// Use direct API call
				const client = new Anthropic({ apiKey });
				const response = await client.messages.create({
					model: 'claude-3-5-haiku-latest',
					max_tokens: 1024,
					messages: [{ role: 'user', content: prompt }]
				});

				const content = response.content[0];
				if (content.type !== 'text') {
					throw new Error('Unexpected response type');
				}
				responseText = content.text;
			} else {
				// Use Claude CLI as fallback (uses user's Claude Code authentication)
				const cliResponse = await claudeCliCall(prompt, { model: 'haiku' });
				responseText = cliResponse.result;
			}

			// Clean and parse JSON
			let jsonText = responseText
				.replace(/^```json\n?/g, '')
				.replace(/^```\n?/g, '')
				.replace(/\n?```$/g, '')
				.trim();

			const llmSummary = JSON.parse(jsonText);

			const summary: TaskSummary = {
				taskId: id,
				title: taskData.title,
				summary: llmSummary.summary || [],
				outcome: llmSummary.outcome || (hasCompletion ? 'completed' : 'incomplete'),
				duration,
				agent,
				keyChanges: llmSummary.keyChanges || [],
				quality: llmSummary.quality,
				suggestedTasks: llmSummary.suggestedTasks || [],
				crossAgentIntel: llmSummary.crossAgentIntel,
				generatedAt: new Date().toISOString()
			};

			// Cache the summary
			await mkdir(summariesDir, { recursive: true });
			await writeFile(summaryFile, JSON.stringify(summary, null, 2));

			return json({
				task_id: id,
				summary,
				cached: false,
				source: apiKey ? 'llm' : 'cli',
				timestamp: new Date().toISOString()
			});

		} catch (llmErr) {
			console.error('LLM summary generation failed:', llmErr);

			// Fallback to basic summary
			const basicSummary: TaskSummary = {
				taskId: id,
				title: taskData.title,
				summary: [`Task "${taskData.title}" ${hasCompletion ? 'was completed' : 'is ' + taskData.status}`],
				outcome: hasCompletion ? 'completed' : (taskData.status === 'blocked' ? 'blocked' : 'incomplete'),
				duration,
				agent,
				keyChanges: [],
				generatedAt: new Date().toISOString()
			};

			return json({
				task_id: id,
				summary: basicSummary,
				cached: false,
				source: 'fallback',
				timestamp: new Date().toISOString()
			});
		}

	} catch (error) {
		const err = error as Error;
		console.error('Error generating task summary:', err);
		return json({
			error: 'Failed to generate task summary',
			message: err.message
		}, { status: 500 });
	}
};
