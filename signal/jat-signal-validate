#!/usr/bin/env bash
#
# jat-signal-validate - Validate signal payloads against JSON schema
#
# Usage (Data Signals):
#   jat-signal-validate tasks '[{...}]'
#   jat-signal-validate action '{...}'
#   jat-signal-validate complete '{...}'
#
# Usage (Rich State Signals):
#   jat-signal-validate working '{"taskId":"...","taskTitle":"..."}'
#   jat-signal-validate review '{"taskId":"...","summary":[...]}'
#   jat-signal-validate needs_input '{"taskId":"...","question":"..."}'
#   jat-signal-validate idle '{"readyForWork":true,...}'
#   jat-signal-validate completing '{"taskId":"...","currentStep":"..."}'
#   jat-signal-validate completed '{"taskId":"...","sessionStats":{...}}'
#   jat-signal-validate starting '{"agentName":"...",...}'
#   jat-signal-validate compacting '{"reason":"...","contextSizeBefore":...}'
#   jat-signal-validate auto_proceed '{"taskId":"...",...}'
#   jat-signal-validate question '{"question":"...","questionType":"choice",...}'
#
# Returns:
#   0 - Valid payload
#   1 - Invalid payload (error message on stderr)
#   2 - Missing jq or invalid arguments

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SCHEMA_FILE="${SCRIPT_DIR}/jat-signal-schema.json"

SIGNAL_TYPE="${1:-}"
PAYLOAD="${2:-}"

show_usage() {
    echo "Usage: jat-signal-validate <signal-type> <json-payload>"
    echo ""
    echo "Data Signal Types:"
    echo "  tasks    - Validate suggested tasks array"
    echo "  action   - Validate human action object"
    echo "  complete - Validate completion bundle object"
    echo ""
    echo "Rich State Signal Types:"
    echo "  working     - Validate rich working signal"
    echo "  review      - Validate rich review signal"
    echo "  needs_input - Validate rich needs_input signal"
    echo "  idle        - Validate rich idle signal"
    echo "  completing  - Validate rich completing signal"
    echo "  completed   - Validate rich completed signal"
    echo "  starting    - Validate rich starting signal"
    echo "  compacting  - Validate rich compacting signal"
    echo "  auto_proceed - Validate rich auto_proceed signal"
    echo "  question    - Validate question signal for dashboard"
    echo ""
    echo "Examples:"
    echo "  jat-signal-validate tasks '[{\"title\":\"Add tests\",\"priority\":2}]'"
    echo "  jat-signal-validate action '{\"title\":\"Run migration\"}'"
    echo "  jat-signal-validate working '{\"taskId\":\"jat-abc\",\"taskTitle\":\"Fix bug\"}'"
    echo "  jat-signal-validate review '{\"taskId\":\"jat-abc\",\"summary\":[\"Fixed the bug\"]}'"
}

if [[ -z "$SIGNAL_TYPE" ]] || [[ -z "$PAYLOAD" ]]; then
    show_usage
    exit 2
fi

# Check jq is available
if ! command -v jq &>/dev/null; then
    echo "Error: jq is required for validation" >&2
    exit 2
fi

# First, check if payload is valid JSON
if ! echo "$PAYLOAD" | jq . >/dev/null 2>&1; then
    echo "Error: Invalid JSON syntax" >&2
    exit 1
fi

# Define validation functions for each signal type
# Since we can't use ajv or jsonschema in bash, we implement basic validation with jq

validate_tasks() {
    local payload="$1"
    local errors=()

    # Must be an array
    if ! echo "$payload" | jq -e 'type == "array"' >/dev/null 2>&1; then
        echo "Error: tasks signal must be a JSON array" >&2
        return 1
    fi

    # Check array is not empty
    local count
    count=$(echo "$payload" | jq 'length')
    if [[ "$count" -eq 0 ]]; then
        echo "Error: tasks array cannot be empty" >&2
        return 1
    fi

    if [[ "$count" -gt 10 ]]; then
        echo "Error: tasks array cannot have more than 10 items" >&2
        return 1
    fi

    # Validate each task
    local i=0
    while [[ $i -lt $count ]]; do
        local task
        task=$(echo "$payload" | jq ".[$i]")

        # Must have title
        if ! echo "$task" | jq -e 'has("title")' >/dev/null 2>&1; then
            echo "Error: task[$i] missing required field 'title'" >&2
            return 1
        fi

        local title
        title=$(echo "$task" | jq -r '.title // ""')
        if [[ -z "$title" ]]; then
            echo "Error: task[$i].title cannot be empty" >&2
            return 1
        fi

        if [[ ${#title} -gt 200 ]]; then
            echo "Error: task[$i].title exceeds 200 character limit" >&2
            return 1
        fi

        # Validate type if present
        local task_type
        task_type=$(echo "$task" | jq -r '.type // ""')
        if [[ -n "$task_type" ]]; then
            case "$task_type" in
                bug|feature|task|chore|epic) ;;
                *)
                    echo "Error: task[$i].type must be one of: bug, feature, task, chore, epic" >&2
                    return 1
                    ;;
            esac
        fi

        # Validate priority if present
        local priority
        priority=$(echo "$task" | jq '.priority // null')
        if [[ "$priority" != "null" ]]; then
            if ! echo "$priority" | grep -qE '^[0-4]$'; then
                echo "Error: task[$i].priority must be 0-4" >&2
                return 1
            fi
        fi

        # Validate description length if present
        local desc_len
        desc_len=$(echo "$task" | jq -r '.description // "" | length')
        if [[ "$desc_len" -gt 2000 ]]; then
            echo "Error: task[$i].description exceeds 2000 character limit" >&2
            return 1
        fi

        # Validate project format if present
        local project
        project=$(echo "$task" | jq -r '.project // ""')
        if [[ -n "$project" ]] && ! echo "$project" | grep -qE '^[a-z0-9_-]+$'; then
            echo "Error: task[$i].project must match pattern ^[a-z0-9_-]+$" >&2
            return 1
        fi

        # Validate depends_on is array if present
        if echo "$task" | jq -e 'has("depends_on")' >/dev/null 2>&1; then
            if ! echo "$task" | jq -e '.depends_on | type == "array"' >/dev/null 2>&1; then
                echo "Error: task[$i].depends_on must be an array" >&2
                return 1
            fi
        fi

        # Check for unknown fields (strict validation)
        local unknown
        unknown=$(echo "$task" | jq -r 'keys - ["id","type","title","description","priority","reason","project","labels","depends_on"] | .[0] // ""')
        if [[ -n "$unknown" ]]; then
            echo "Error: task[$i] has unknown field '$unknown'" >&2
            return 1
        fi

        i=$((i + 1))
    done

    return 0
}

validate_action() {
    local payload="$1"

    # Must be an object
    if ! echo "$payload" | jq -e 'type == "object"' >/dev/null 2>&1; then
        echo "Error: action signal must be a JSON object" >&2
        return 1
    fi

    # Must have title
    if ! echo "$payload" | jq -e 'has("title")' >/dev/null 2>&1; then
        echo "Error: action missing required field 'title'" >&2
        return 1
    fi

    local title
    title=$(echo "$payload" | jq -r '.title // ""')
    if [[ -z "$title" ]]; then
        echo "Error: action.title cannot be empty" >&2
        return 1
    fi

    if [[ ${#title} -gt 200 ]]; then
        echo "Error: action.title exceeds 200 character limit" >&2
        return 1
    fi

    # Validate description length if present
    local desc_len
    desc_len=$(echo "$payload" | jq -r '.description // "" | length')
    if [[ "$desc_len" -gt 2000 ]]; then
        echo "Error: action.description exceeds 2000 character limit" >&2
        return 1
    fi

    # Validate items is array if present
    if echo "$payload" | jq -e 'has("items")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.items | type == "array"' >/dev/null 2>&1; then
            echo "Error: action.items must be an array" >&2
            return 1
        fi
        # All items must be strings
        if ! echo "$payload" | jq -e '.items | all(type == "string")' >/dev/null 2>&1; then
            echo "Error: action.items must contain only strings" >&2
            return 1
        fi
    fi

    # Check for unknown fields
    local unknown
    unknown=$(echo "$payload" | jq -r 'keys - ["title","description","items"] | .[0] // ""')
    if [[ -n "$unknown" ]]; then
        echo "Error: action has unknown field '$unknown'" >&2
        return 1
    fi

    return 0
}

validate_quality_signals() {
    local payload="$1"
    local prefix="$2"

    # Validate tests if present
    local tests
    tests=$(echo "$payload" | jq -r '.tests // ""')
    if [[ -n "$tests" ]]; then
        case "$tests" in
            passing|failing|none|skipped) ;;
            *)
                echo "Error: ${prefix}quality.tests must be one of: passing, failing, none, skipped" >&2
                return 1
                ;;
        esac
    fi

    # Validate build if present
    local build
    build=$(echo "$payload" | jq -r '.build // ""')
    if [[ -n "$build" ]]; then
        case "$build" in
            clean|warnings|errors) ;;
            *)
                echo "Error: ${prefix}quality.build must be one of: clean, warnings, errors" >&2
                return 1
                ;;
        esac
    fi

    # Check for unknown fields
    local unknown
    unknown=$(echo "$payload" | jq -r 'keys - ["tests","build","preExisting"] | .[0] // ""')
    if [[ -n "$unknown" ]]; then
        echo "Error: ${prefix}quality has unknown field '$unknown'" >&2
        return 1
    fi

    return 0
}

validate_cross_agent_intel() {
    local payload="$1"
    local prefix="$2"

    # Validate files is array of strings if present
    if echo "$payload" | jq -e 'has("files")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.files | type == "array"' >/dev/null 2>&1; then
            echo "Error: ${prefix}crossAgentIntel.files must be an array" >&2
            return 1
        fi
        if ! echo "$payload" | jq -e '.files | all(type == "string")' >/dev/null 2>&1; then
            echo "Error: ${prefix}crossAgentIntel.files must contain only strings" >&2
            return 1
        fi
    fi

    # Validate patterns is array of strings if present
    if echo "$payload" | jq -e 'has("patterns")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.patterns | type == "array"' >/dev/null 2>&1; then
            echo "Error: ${prefix}crossAgentIntel.patterns must be an array" >&2
            return 1
        fi
        if ! echo "$payload" | jq -e '.patterns | all(type == "string")' >/dev/null 2>&1; then
            echo "Error: ${prefix}crossAgentIntel.patterns must contain only strings" >&2
            return 1
        fi
    fi

    # Validate gotchas is array of strings if present
    if echo "$payload" | jq -e 'has("gotchas")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.gotchas | type == "array"' >/dev/null 2>&1; then
            echo "Error: ${prefix}crossAgentIntel.gotchas must be an array" >&2
            return 1
        fi
        if ! echo "$payload" | jq -e '.gotchas | all(type == "string")' >/dev/null 2>&1; then
            echo "Error: ${prefix}crossAgentIntel.gotchas must contain only strings" >&2
            return 1
        fi
    fi

    # Check for unknown fields
    local unknown
    unknown=$(echo "$payload" | jq -r 'keys - ["files","patterns","gotchas"] | .[0] // ""')
    if [[ -n "$unknown" ]]; then
        echo "Error: ${prefix}crossAgentIntel has unknown field '$unknown'" >&2
        return 1
    fi

    return 0
}

# =============================================================================
# Rich State Signal Validators
# =============================================================================

validate_working() {
    local payload="$1"

    # Must be an object
    if ! echo "$payload" | jq -e 'type == "object"' >/dev/null 2>&1; then
        echo "Error: working signal must be a JSON object" >&2
        return 1
    fi

    # Required: taskId
    if ! echo "$payload" | jq -e 'has("taskId")' >/dev/null 2>&1; then
        echo "Error: working signal missing required field 'taskId'" >&2
        return 1
    fi

    local task_id
    task_id=$(echo "$payload" | jq -r '.taskId // ""')
    if [[ -z "$task_id" ]]; then
        echo "Error: working.taskId cannot be empty" >&2
        return 1
    fi

    # Validate taskPriority if present
    local priority
    priority=$(echo "$payload" | jq '.taskPriority // null')
    if [[ "$priority" != "null" ]]; then
        if ! echo "$priority" | grep -qE '^[0-4]$'; then
            echo "Error: working.taskPriority must be 0-4" >&2
            return 1
        fi
    fi

    # Validate estimatedScope if present
    local scope
    scope=$(echo "$payload" | jq -r '.estimatedScope // ""')
    if [[ -n "$scope" ]]; then
        case "$scope" in
            small|medium|large) ;;
            *)
                echo "Error: working.estimatedScope must be one of: small, medium, large" >&2
                return 1
                ;;
        esac
    fi

    # Validate expectedFiles is array if present
    if echo "$payload" | jq -e 'has("expectedFiles")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.expectedFiles | type == "array"' >/dev/null 2>&1; then
            echo "Error: working.expectedFiles must be an array" >&2
            return 1
        fi
    fi

    # Validate dependencies is array if present
    if echo "$payload" | jq -e 'has("dependencies")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.dependencies | type == "array"' >/dev/null 2>&1; then
            echo "Error: working.dependencies must be an array" >&2
            return 1
        fi
    fi

    return 0
}

validate_review() {
    local payload="$1"

    # Must be an object
    if ! echo "$payload" | jq -e 'type == "object"' >/dev/null 2>&1; then
        echo "Error: review signal must be a JSON object" >&2
        return 1
    fi

    # Required: taskId
    if ! echo "$payload" | jq -e 'has("taskId")' >/dev/null 2>&1; then
        echo "Error: review signal missing required field 'taskId'" >&2
        return 1
    fi

    # Validate summary is array of strings if present
    if echo "$payload" | jq -e 'has("summary")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.summary | type == "array"' >/dev/null 2>&1; then
            echo "Error: review.summary must be an array" >&2
            return 1
        fi
        if ! echo "$payload" | jq -e '.summary | all(type == "string")' >/dev/null 2>&1; then
            echo "Error: review.summary must contain only strings" >&2
            return 1
        fi
    fi

    # Validate testsStatus if present
    local tests_status
    tests_status=$(echo "$payload" | jq -r '.testsStatus // ""')
    if [[ -n "$tests_status" ]]; then
        case "$tests_status" in
            passing|failing|none|skipped) ;;
            *)
                echo "Error: review.testsStatus must be one of: passing, failing, none, skipped" >&2
                return 1
                ;;
        esac
    fi

    # Validate buildStatus if present
    local build_status
    build_status=$(echo "$payload" | jq -r '.buildStatus // ""')
    if [[ -n "$build_status" ]]; then
        case "$build_status" in
            clean|warnings|errors) ;;
            *)
                echo "Error: review.buildStatus must be one of: clean, warnings, errors" >&2
                return 1
                ;;
        esac
    fi

    # Validate filesModified is array if present
    if echo "$payload" | jq -e 'has("filesModified")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.filesModified | type == "array"' >/dev/null 2>&1; then
            echo "Error: review.filesModified must be an array" >&2
            return 1
        fi
        # Validate each file modification object
        local count
        count=$(echo "$payload" | jq '.filesModified | length')
        local i=0
        while [[ $i -lt $count ]]; do
            local file_mod
            file_mod=$(echo "$payload" | jq ".filesModified[$i]")

            # path is required
            if ! echo "$file_mod" | jq -e 'has("path")' >/dev/null 2>&1; then
                echo "Error: review.filesModified[$i] missing required field 'path'" >&2
                return 1
            fi

            # changeType if present must be valid
            local change_type
            change_type=$(echo "$file_mod" | jq -r '.changeType // ""')
            if [[ -n "$change_type" ]]; then
                case "$change_type" in
                    added|modified|deleted) ;;
                    *)
                        echo "Error: review.filesModified[$i].changeType must be one of: added, modified, deleted" >&2
                        return 1
                        ;;
                esac
            fi

            i=$((i + 1))
        done
    fi

    # Validate keyDecisions is array if present
    if echo "$payload" | jq -e 'has("keyDecisions")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.keyDecisions | type == "array"' >/dev/null 2>&1; then
            echo "Error: review.keyDecisions must be an array" >&2
            return 1
        fi
        # Validate each key decision has decision field
        local count
        count=$(echo "$payload" | jq '.keyDecisions | length')
        local i=0
        while [[ $i -lt $count ]]; do
            if ! echo "$payload" | jq -e ".keyDecisions[$i] | has(\"decision\")" >/dev/null 2>&1; then
                echo "Error: review.keyDecisions[$i] missing required field 'decision'" >&2
                return 1
            fi
            i=$((i + 1))
        done
    fi

    # Validate reviewFocus is array of strings or objects with 'text' field if present
    if echo "$payload" | jq -e 'has("reviewFocus")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.reviewFocus | type == "array"' >/dev/null 2>&1; then
            echo "Error: review.reviewFocus must be an array" >&2
            return 1
        fi
        # Each item must be either a string or an object with 'text' field
        local count
        count=$(echo "$payload" | jq '.reviewFocus | length')
        local i=0
        while [[ $i -lt $count ]]; do
            local item
            item=$(echo "$payload" | jq ".reviewFocus[$i]")
            local item_type
            item_type=$(echo "$item" | jq -r 'type')

            if [[ "$item_type" == "string" ]]; then
                # String item is valid
                :
            elif [[ "$item_type" == "object" ]]; then
                # Object must have 'text' field
                if ! echo "$item" | jq -e 'has("text")' >/dev/null 2>&1; then
                    echo "Error: review.reviewFocus[$i] object missing required field 'text'" >&2
                    return 1
                fi
                local text
                text=$(echo "$item" | jq -r '.text // ""')
                if [[ -z "$text" ]]; then
                    echo "Error: review.reviewFocus[$i].text cannot be empty" >&2
                    return 1
                fi
                # Validate optional fields
                if echo "$item" | jq -e 'has("line")' >/dev/null 2>&1; then
                    local line
                    line=$(echo "$item" | jq '.line')
                    if ! echo "$line" | grep -qE '^[1-9][0-9]*$'; then
                        echo "Error: review.reviewFocus[$i].line must be a positive integer" >&2
                        return 1
                    fi
                fi
                # Check for unknown fields
                local unknown
                unknown=$(echo "$item" | jq -r 'keys - ["text","filePath","localhostRoute","line"] | .[0] // ""')
                if [[ -n "$unknown" ]]; then
                    echo "Error: review.reviewFocus[$i] has unknown field '$unknown'" >&2
                    return 1
                fi
            else
                echo "Error: review.reviewFocus[$i] must be a string or object with 'text' field" >&2
                return 1
            fi

            i=$((i + 1))
        done
    fi

    # Validate knownLimitations is array of strings if present
    if echo "$payload" | jq -e 'has("knownLimitations")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.knownLimitations | type == "array"' >/dev/null 2>&1; then
            echo "Error: review.knownLimitations must be an array" >&2
            return 1
        fi
        if ! echo "$payload" | jq -e '.knownLimitations | all(type == "string")' >/dev/null 2>&1; then
            echo "Error: review.knownLimitations must contain only strings" >&2
            return 1
        fi
    fi

    # Validate buildWarnings is array of strings if present
    if echo "$payload" | jq -e 'has("buildWarnings")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.buildWarnings | type == "array"' >/dev/null 2>&1; then
            echo "Error: review.buildWarnings must be an array" >&2
            return 1
        fi
        if ! echo "$payload" | jq -e '.buildWarnings | all(type == "string")' >/dev/null 2>&1; then
            echo "Error: review.buildWarnings must contain only strings" >&2
            return 1
        fi
    fi

    # Validate commits is array if present
    if echo "$payload" | jq -e 'has("commits")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.commits | type == "array"' >/dev/null 2>&1; then
            echo "Error: review.commits must be an array" >&2
            return 1
        fi
        # Validate each commit has sha and message
        local count
        count=$(echo "$payload" | jq '.commits | length')
        local i=0
        while [[ $i -lt $count ]]; do
            local commit
            commit=$(echo "$payload" | jq ".commits[$i]")
            if ! echo "$commit" | jq -e 'has("sha")' >/dev/null 2>&1; then
                echo "Error: review.commits[$i] missing required field 'sha'" >&2
                return 1
            fi
            if ! echo "$commit" | jq -e 'has("message")' >/dev/null 2>&1; then
                echo "Error: review.commits[$i] missing required field 'message'" >&2
                return 1
            fi
            i=$((i + 1))
        done
    fi

    # Validate numeric fields if present
    local total_added total_removed tests_run tests_passed
    total_added=$(echo "$payload" | jq '.totalLinesAdded // null')
    total_removed=$(echo "$payload" | jq '.totalLinesRemoved // null')
    tests_run=$(echo "$payload" | jq '.testsRun // null')
    tests_passed=$(echo "$payload" | jq '.testsPassed // null')

    if [[ "$total_added" != "null" ]] && ! echo "$total_added" | grep -qE '^[0-9]+$'; then
        echo "Error: review.totalLinesAdded must be a non-negative integer" >&2
        return 1
    fi
    if [[ "$total_removed" != "null" ]] && ! echo "$total_removed" | grep -qE '^[0-9]+$'; then
        echo "Error: review.totalLinesRemoved must be a non-negative integer" >&2
        return 1
    fi
    if [[ "$tests_run" != "null" ]] && ! echo "$tests_run" | grep -qE '^[0-9]+$'; then
        echo "Error: review.testsRun must be a non-negative integer" >&2
        return 1
    fi
    if [[ "$tests_passed" != "null" ]] && ! echo "$tests_passed" | grep -qE '^[0-9]+$'; then
        echo "Error: review.testsPassed must be a non-negative integer" >&2
        return 1
    fi

    return 0
}

validate_needs_input() {
    local payload="$1"

    # Must be an object
    if ! echo "$payload" | jq -e 'type == "object"' >/dev/null 2>&1; then
        echo "Error: needs_input signal must be a JSON object" >&2
        return 1
    fi

    # Required: taskId
    if ! echo "$payload" | jq -e 'has("taskId")' >/dev/null 2>&1; then
        echo "Error: needs_input signal missing required field 'taskId'" >&2
        return 1
    fi

    # Required: question
    if ! echo "$payload" | jq -e 'has("question")' >/dev/null 2>&1; then
        echo "Error: needs_input signal missing required field 'question'" >&2
        return 1
    fi

    local question
    question=$(echo "$payload" | jq -r '.question // ""')
    if [[ -z "$question" ]]; then
        echo "Error: needs_input.question cannot be empty" >&2
        return 1
    fi

    # Required: questionType
    if ! echo "$payload" | jq -e 'has("questionType")' >/dev/null 2>&1; then
        echo "Error: needs_input signal missing required field 'questionType'" >&2
        return 1
    fi

    local question_type
    question_type=$(echo "$payload" | jq -r '.questionType // ""')
    case "$question_type" in
        choice|text|approval|clarification) ;;
        *)
            echo "Error: needs_input.questionType must be one of: choice, text, approval, clarification" >&2
            return 1
            ;;
    esac

    # Validate options is array if present
    if echo "$payload" | jq -e 'has("options")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.options | type == "array"' >/dev/null 2>&1; then
            echo "Error: needs_input.options must be an array" >&2
            return 1
        fi
    fi

    return 0
}

validate_idle() {
    local payload="$1"

    # Must be an object
    if ! echo "$payload" | jq -e 'type == "object"' >/dev/null 2>&1; then
        echo "Error: idle signal must be a JSON object" >&2
        return 1
    fi

    # Required: readyForWork (boolean)
    if ! echo "$payload" | jq -e 'has("readyForWork")' >/dev/null 2>&1; then
        echo "Error: idle signal missing required field 'readyForWork'" >&2
        return 1
    fi
    if ! echo "$payload" | jq -e '.readyForWork | type == "boolean"' >/dev/null 2>&1; then
        echo "Error: idle.readyForWork must be a boolean" >&2
        return 1
    fi

    # Validate sessionSummary if present
    if echo "$payload" | jq -e 'has("sessionSummary")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.sessionSummary | type == "object"' >/dev/null 2>&1; then
            echo "Error: idle.sessionSummary must be an object" >&2
            return 1
        fi

        local session_summary
        session_summary=$(echo "$payload" | jq '.sessionSummary')

        # Validate tasksCompleted is array of strings if present
        if echo "$session_summary" | jq -e 'has("tasksCompleted")' >/dev/null 2>&1; then
            if ! echo "$session_summary" | jq -e '.tasksCompleted | type == "array"' >/dev/null 2>&1; then
                echo "Error: idle.sessionSummary.tasksCompleted must be an array" >&2
                return 1
            fi
            if ! echo "$session_summary" | jq -e '.tasksCompleted | all(type == "string")' >/dev/null 2>&1; then
                echo "Error: idle.sessionSummary.tasksCompleted must contain only strings" >&2
                return 1
            fi
        fi

        # Validate numeric fields if present
        local total_duration tokens_used files_modified
        total_duration=$(echo "$session_summary" | jq '.totalDuration // null')
        tokens_used=$(echo "$session_summary" | jq '.tokensUsed // null')
        files_modified=$(echo "$session_summary" | jq '.filesModified // null')

        if [[ "$total_duration" != "null" ]] && ! echo "$total_duration" | grep -qE '^[0-9]+$'; then
            echo "Error: idle.sessionSummary.totalDuration must be a non-negative integer" >&2
            return 1
        fi
        if [[ "$tokens_used" != "null" ]] && ! echo "$tokens_used" | grep -qE '^[0-9]+$'; then
            echo "Error: idle.sessionSummary.tokensUsed must be a non-negative integer" >&2
            return 1
        fi
        if [[ "$files_modified" != "null" ]] && ! echo "$files_modified" | grep -qE '^[0-9]+$'; then
            echo "Error: idle.sessionSummary.filesModified must be a non-negative integer" >&2
            return 1
        fi

        # Check for unknown fields in sessionSummary
        local unknown
        unknown=$(echo "$session_summary" | jq -r 'keys - ["tasksCompleted","totalDuration","tokensUsed","filesModified"] | .[0] // ""')
        if [[ -n "$unknown" ]]; then
            echo "Error: idle.sessionSummary has unknown field '$unknown'" >&2
            return 1
        fi
    fi

    # Validate suggestedNextTask if present
    if echo "$payload" | jq -e 'has("suggestedNextTask")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.suggestedNextTask | type == "object"' >/dev/null 2>&1; then
            echo "Error: idle.suggestedNextTask must be an object" >&2
            return 1
        fi

        local suggested_next
        suggested_next=$(echo "$payload" | jq '.suggestedNextTask')

        # Required fields: taskId, title, reason
        if ! echo "$suggested_next" | jq -e 'has("taskId")' >/dev/null 2>&1; then
            echo "Error: idle.suggestedNextTask missing required field 'taskId'" >&2
            return 1
        fi
        local task_id
        task_id=$(echo "$suggested_next" | jq -r '.taskId // ""')
        if [[ -z "$task_id" ]]; then
            echo "Error: idle.suggestedNextTask.taskId cannot be empty" >&2
            return 1
        fi

        if ! echo "$suggested_next" | jq -e 'has("title")' >/dev/null 2>&1; then
            echo "Error: idle.suggestedNextTask missing required field 'title'" >&2
            return 1
        fi
        local title
        title=$(echo "$suggested_next" | jq -r '.title // ""')
        if [[ -z "$title" ]]; then
            echo "Error: idle.suggestedNextTask.title cannot be empty" >&2
            return 1
        fi

        if ! echo "$suggested_next" | jq -e 'has("reason")' >/dev/null 2>&1; then
            echo "Error: idle.suggestedNextTask missing required field 'reason'" >&2
            return 1
        fi
        local reason
        reason=$(echo "$suggested_next" | jq -r '.reason // ""')
        if [[ -z "$reason" ]]; then
            echo "Error: idle.suggestedNextTask.reason cannot be empty" >&2
            return 1
        fi

        # Check for unknown fields in suggestedNextTask
        local unknown
        unknown=$(echo "$suggested_next" | jq -r 'keys - ["taskId","title","reason"] | .[0] // ""')
        if [[ -n "$unknown" ]]; then
            echo "Error: idle.suggestedNextTask has unknown field '$unknown'" >&2
            return 1
        fi
    fi

    # Validate blockedReason if present
    if echo "$payload" | jq -e 'has("blockedReason")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.blockedReason | type == "string"' >/dev/null 2>&1; then
            echo "Error: idle.blockedReason must be a string" >&2
            return 1
        fi
    fi

    # Check for unknown fields in idle signal
    local unknown
    unknown=$(echo "$payload" | jq -r 'keys - ["readyForWork","sessionSummary","suggestedNextTask","blockedReason"] | .[0] // ""')
    if [[ -n "$unknown" ]]; then
        echo "Error: idle signal has unknown field '$unknown'" >&2
        return 1
    fi

    return 0
}

validate_completing() {
    local payload="$1"

    # Must be an object
    if ! echo "$payload" | jq -e 'type == "object"' >/dev/null 2>&1; then
        echo "Error: completing signal must be a JSON object" >&2
        return 1
    fi

    # Required: taskId
    if ! echo "$payload" | jq -e 'has("taskId")' >/dev/null 2>&1; then
        echo "Error: completing signal missing required field 'taskId'" >&2
        return 1
    fi

    # Required: currentStep
    if ! echo "$payload" | jq -e 'has("currentStep")' >/dev/null 2>&1; then
        echo "Error: completing signal missing required field 'currentStep'" >&2
        return 1
    fi

    local current_step
    current_step=$(echo "$payload" | jq -r '.currentStep // ""')
    case "$current_step" in
        verifying|committing|closing|releasing|announcing) ;;
        *)
            echo "Error: completing.currentStep must be one of: verifying, committing, closing, releasing, announcing" >&2
            return 1
            ;;
    esac

    # Validate progress is 0-100 if present
    local progress
    progress=$(echo "$payload" | jq '.progress // null')
    if [[ "$progress" != "null" ]]; then
        if ! echo "$progress" | grep -qE '^[0-9]+$' || [[ "$progress" -lt 0 ]] || [[ "$progress" -gt 100 ]]; then
            echo "Error: completing.progress must be 0-100" >&2
            return 1
        fi
    fi

    return 0
}

validate_completed() {
    local payload="$1"

    # Must be an object
    if ! echo "$payload" | jq -e 'type == "object"' >/dev/null 2>&1; then
        echo "Error: completed signal must be a JSON object" >&2
        return 1
    fi

    # Required: taskId
    if ! echo "$payload" | jq -e 'has("taskId")' >/dev/null 2>&1; then
        echo "Error: completed signal missing required field 'taskId'" >&2
        return 1
    fi

    local task_id
    task_id=$(echo "$payload" | jq -r '.taskId // ""')
    if [[ -z "$task_id" ]]; then
        echo "Error: completed.taskId cannot be empty" >&2
        return 1
    fi

    # Validate agentName if present (should be string)
    if echo "$payload" | jq -e 'has("agentName")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.agentName | type == "string"' >/dev/null 2>&1; then
            echo "Error: completed.agentName must be a string" >&2
            return 1
        fi
    fi

    # Validate summary is array of strings if present
    if echo "$payload" | jq -e 'has("summary")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.summary | type == "array"' >/dev/null 2>&1; then
            echo "Error: completed.summary must be an array" >&2
            return 1
        fi
        if ! echo "$payload" | jq -e '.summary | all(type == "string")' >/dev/null 2>&1; then
            echo "Error: completed.summary must contain only strings" >&2
            return 1
        fi
    fi

    # Validate quality if present
    if echo "$payload" | jq -e 'has("quality")' >/dev/null 2>&1; then
        local quality
        quality=$(echo "$payload" | jq '.quality')
        if ! echo "$quality" | jq -e 'type == "object"' >/dev/null 2>&1; then
            echo "Error: completed.quality must be an object" >&2
            return 1
        fi
        validate_quality_signals "$quality" "completed." || return 1
    fi

    # Validate humanActions if present
    if echo "$payload" | jq -e 'has("humanActions")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.humanActions | type == "array"' >/dev/null 2>&1; then
            echo "Error: completed.humanActions must be an array" >&2
            return 1
        fi
        local count
        count=$(echo "$payload" | jq '.humanActions | length')
        local i=0
        while [[ $i -lt $count ]]; do
            local action
            action=$(echo "$payload" | jq ".humanActions[$i]")

            if ! echo "$action" | jq -e 'has("title")' >/dev/null 2>&1; then
                echo "Error: completed.humanActions[$i] missing required field 'title'" >&2
                return 1
            fi

            local title
            title=$(echo "$action" | jq -r '.title // ""')
            if [[ -z "$title" ]]; then
                echo "Error: completed.humanActions[$i].title cannot be empty" >&2
                return 1
            fi

            i=$((i + 1))
        done
    fi

    # Validate suggestedTasks if present
    if echo "$payload" | jq -e 'has("suggestedTasks")' >/dev/null 2>&1; then
        local tasks
        tasks=$(echo "$payload" | jq '.suggestedTasks')
        if ! echo "$tasks" | jq -e 'type == "array"' >/dev/null 2>&1; then
            echo "Error: completed.suggestedTasks must be an array" >&2
            return 1
        fi
        local count
        count=$(echo "$tasks" | jq 'length')
        local i=0
        while [[ $i -lt $count ]]; do
            local task
            task=$(echo "$tasks" | jq ".[$i]")

            if ! echo "$task" | jq -e 'has("title")' >/dev/null 2>&1; then
                echo "Error: completed.suggestedTasks[$i] missing required field 'title'" >&2
                return 1
            fi

            local title
            title=$(echo "$task" | jq -r '.title // ""')
            if [[ -z "$title" ]]; then
                echo "Error: completed.suggestedTasks[$i].title cannot be empty" >&2
                return 1
            fi

            i=$((i + 1))
        done
    fi

    # Validate crossAgentIntel if present
    if echo "$payload" | jq -e 'has("crossAgentIntel")' >/dev/null 2>&1; then
        local intel
        intel=$(echo "$payload" | jq '.crossAgentIntel')
        if ! echo "$intel" | jq -e 'type == "object"' >/dev/null 2>&1; then
            echo "Error: completed.crossAgentIntel must be an object" >&2
            return 1
        fi
        validate_cross_agent_intel "$intel" "completed." || return 1
    fi

    # Validate sessionStats if present (NEW: full validation)
    if echo "$payload" | jq -e 'has("sessionStats")' >/dev/null 2>&1; then
        local session_stats
        session_stats=$(echo "$payload" | jq '.sessionStats')
        if ! echo "$session_stats" | jq -e 'type == "object"' >/dev/null 2>&1; then
            echo "Error: completed.sessionStats must be an object" >&2
            return 1
        fi

        # Validate sessionStats.duration if present (non-negative integer)
        local duration
        duration=$(echo "$session_stats" | jq '.duration // null')
        if [[ "$duration" != "null" ]]; then
            if ! echo "$duration" | grep -qE '^[0-9]+$'; then
                echo "Error: completed.sessionStats.duration must be a non-negative integer" >&2
                return 1
            fi
        fi

        # Validate sessionStats.tokensUsed if present (non-negative integer)
        local tokens_used
        tokens_used=$(echo "$session_stats" | jq '.tokensUsed // null')
        if [[ "$tokens_used" != "null" ]]; then
            if ! echo "$tokens_used" | grep -qE '^[0-9]+$'; then
                echo "Error: completed.sessionStats.tokensUsed must be a non-negative integer" >&2
                return 1
            fi
        fi

        # Validate sessionStats.filesModified if present (non-negative integer)
        local files_modified
        files_modified=$(echo "$session_stats" | jq '.filesModified // null')
        if [[ "$files_modified" != "null" ]]; then
            if ! echo "$files_modified" | grep -qE '^[0-9]+$'; then
                echo "Error: completed.sessionStats.filesModified must be a non-negative integer" >&2
                return 1
            fi
        fi

        # Validate sessionStats.linesChanged if present (non-negative integer)
        local lines_changed
        lines_changed=$(echo "$session_stats" | jq '.linesChanged // null')
        if [[ "$lines_changed" != "null" ]]; then
            if ! echo "$lines_changed" | grep -qE '^[0-9]+$'; then
                echo "Error: completed.sessionStats.linesChanged must be a non-negative integer" >&2
                return 1
            fi
        fi

        # Validate sessionStats.commitsCreated if present (non-negative integer)
        local commits_created
        commits_created=$(echo "$session_stats" | jq '.commitsCreated // null')
        if [[ "$commits_created" != "null" ]]; then
            if ! echo "$commits_created" | grep -qE '^[0-9]+$'; then
                echo "Error: completed.sessionStats.commitsCreated must be a non-negative integer" >&2
                return 1
            fi
        fi

        # Check for unknown fields in sessionStats
        local unknown
        unknown=$(echo "$session_stats" | jq -r 'keys - ["duration","tokensUsed","filesModified","linesChanged","commitsCreated"] | .[0] // ""')
        if [[ -n "$unknown" ]]; then
            echo "Error: completed.sessionStats has unknown field '$unknown'" >&2
            return 1
        fi
    fi

    # Validate finalCommit if present (should be string)
    if echo "$payload" | jq -e 'has("finalCommit")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.finalCommit | type == "string"' >/dev/null 2>&1; then
            echo "Error: completed.finalCommit must be a string" >&2
            return 1
        fi
    fi

    # Validate prLink if present (should be string)
    if echo "$payload" | jq -e 'has("prLink")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.prLink | type == "string"' >/dev/null 2>&1; then
            echo "Error: completed.prLink must be a string" >&2
            return 1
        fi
    fi

    return 0
}

validate_starting() {
    local payload="$1"

    # Must be an object
    if ! echo "$payload" | jq -e 'type == "object"' >/dev/null 2>&1; then
        echo "Error: starting signal must be a JSON object" >&2
        return 1
    fi

    # Required: agentName
    if ! echo "$payload" | jq -e 'has("agentName")' >/dev/null 2>&1; then
        echo "Error: starting signal missing required field 'agentName'" >&2
        return 1
    fi

    local agent_name
    agent_name=$(echo "$payload" | jq -r '.agentName // ""')
    if [[ -z "$agent_name" ]]; then
        echo "Error: starting.agentName cannot be empty" >&2
        return 1
    fi

    # Validate sessionId if present (should be string, UUID format)
    if echo "$payload" | jq -e 'has("sessionId")' >/dev/null 2>&1; then
        local session_id
        session_id=$(echo "$payload" | jq -r '.sessionId // ""')
        if [[ -z "$session_id" ]]; then
            echo "Error: starting.sessionId cannot be empty when provided" >&2
            return 1
        fi
    fi

    # Validate taskId if present (should be non-empty string)
    if echo "$payload" | jq -e 'has("taskId")' >/dev/null 2>&1; then
        local task_id
        task_id=$(echo "$payload" | jq -r '.taskId // ""')
        if [[ -z "$task_id" ]]; then
            echo "Error: starting.taskId cannot be empty when provided" >&2
            return 1
        fi
    fi

    # Validate taskTitle if present (should be non-empty string)
    if echo "$payload" | jq -e 'has("taskTitle")' >/dev/null 2>&1; then
        local task_title
        task_title=$(echo "$payload" | jq -r '.taskTitle // ""')
        if [[ -z "$task_title" ]]; then
            echo "Error: starting.taskTitle cannot be empty when provided" >&2
            return 1
        fi
    fi

    # Validate project if present (should be non-empty string)
    if echo "$payload" | jq -e 'has("project")' >/dev/null 2>&1; then
        local project
        project=$(echo "$payload" | jq -r '.project // ""')
        if [[ -z "$project" ]]; then
            echo "Error: starting.project cannot be empty when provided" >&2
            return 1
        fi
    fi

    # Validate gitStatus if present
    local git_status
    git_status=$(echo "$payload" | jq -r '.gitStatus // ""')
    if [[ -n "$git_status" ]]; then
        case "$git_status" in
            clean|dirty) ;;
            *)
                echo "Error: starting.gitStatus must be one of: clean, dirty" >&2
                return 1
                ;;
        esac
    fi

    # Validate tools is array if present
    if echo "$payload" | jq -e 'has("tools")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.tools | type == "array"' >/dev/null 2>&1; then
            echo "Error: starting.tools must be an array" >&2
            return 1
        fi
    fi

    return 0
}

validate_compacting() {
    local payload="$1"

    # Must be an object
    if ! echo "$payload" | jq -e 'type == "object"' >/dev/null 2>&1; then
        echo "Error: compacting signal must be a JSON object" >&2
        return 1
    fi

    # Required: reason
    if ! echo "$payload" | jq -e 'has("reason")' >/dev/null 2>&1; then
        echo "Error: compacting signal missing required field 'reason'" >&2
        return 1
    fi

    local reason
    reason=$(echo "$payload" | jq -r '.reason // ""')
    if [[ -z "$reason" ]]; then
        echo "Error: compacting.reason cannot be empty" >&2
        return 1
    fi

    # Required: contextSizeBefore
    if ! echo "$payload" | jq -e 'has("contextSizeBefore")' >/dev/null 2>&1; then
        echo "Error: compacting signal missing required field 'contextSizeBefore'" >&2
        return 1
    fi

    local context_size
    context_size=$(echo "$payload" | jq '.contextSizeBefore // null')
    if [[ "$context_size" == "null" ]] || ! echo "$context_size" | grep -qE '^[0-9]+$'; then
        echo "Error: compacting.contextSizeBefore must be a positive integer" >&2
        return 1
    fi

    # Validate preserving is array if present
    if echo "$payload" | jq -e 'has("preserving")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.preserving | type == "array"' >/dev/null 2>&1; then
            echo "Error: compacting.preserving must be an array" >&2
            return 1
        fi
    fi

    return 0
}

validate_auto_proceed() {
    local payload="$1"

    # Must be an object
    if ! echo "$payload" | jq -e 'type == "object"' >/dev/null 2>&1; then
        echo "Error: auto_proceed signal must be a JSON object" >&2
        return 1
    fi

    # Required: taskId
    if ! echo "$payload" | jq -e 'has("taskId")' >/dev/null 2>&1; then
        echo "Error: auto_proceed signal missing required field 'taskId'" >&2
        return 1
    fi

    local task_id
    task_id=$(echo "$payload" | jq -r '.taskId // ""')
    if [[ -z "$task_id" ]]; then
        echo "Error: auto_proceed.taskId cannot be empty" >&2
        return 1
    fi

    return 0
}

validate_question() {
    local payload="$1"

    # Must be an object
    if ! echo "$payload" | jq -e 'type == "object"' >/dev/null 2>&1; then
        echo "Error: question signal must be a JSON object" >&2
        return 1
    fi

    # Required: question (string)
    if ! echo "$payload" | jq -e 'has("question")' >/dev/null 2>&1; then
        echo "Error: question signal missing required field 'question'" >&2
        return 1
    fi

    local question
    question=$(echo "$payload" | jq -r '.question // ""')
    if [[ -z "$question" ]]; then
        echo "Error: question.question cannot be empty" >&2
        return 1
    fi

    # Required: questionType (must be one of: choice, confirm, input)
    if ! echo "$payload" | jq -e 'has("questionType")' >/dev/null 2>&1; then
        echo "Error: question signal missing required field 'questionType'" >&2
        return 1
    fi

    local question_type
    question_type=$(echo "$payload" | jq -r '.questionType // ""')
    case "$question_type" in
        choice|confirm|input) ;;
        *)
            echo "Error: question.questionType must be one of: choice, confirm, input" >&2
            return 1
            ;;
    esac

    # Validate options array if present
    if echo "$payload" | jq -e 'has("options")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.options | type == "array"' >/dev/null 2>&1; then
            echo "Error: question.options must be an array" >&2
            return 1
        fi

        # Validate each option has label and value
        local count
        count=$(echo "$payload" | jq '.options | length')
        local i=0
        while [[ $i -lt $count ]]; do
            local option
            option=$(echo "$payload" | jq ".options[$i]")

            # Required: label
            if ! echo "$option" | jq -e 'has("label")' >/dev/null 2>&1; then
                echo "Error: question.options[$i] missing required field 'label'" >&2
                return 1
            fi
            local label
            label=$(echo "$option" | jq -r '.label // ""')
            if [[ -z "$label" ]]; then
                echo "Error: question.options[$i].label cannot be empty" >&2
                return 1
            fi

            # Required: value
            if ! echo "$option" | jq -e 'has("value")' >/dev/null 2>&1; then
                echo "Error: question.options[$i] missing required field 'value'" >&2
                return 1
            fi
            local value
            value=$(echo "$option" | jq -r '.value // ""')
            if [[ -z "$value" ]]; then
                echo "Error: question.options[$i].value cannot be empty" >&2
                return 1
            fi

            # description is optional, but if present must be a string
            if echo "$option" | jq -e 'has("description")' >/dev/null 2>&1; then
                if ! echo "$option" | jq -e '.description | type == "string"' >/dev/null 2>&1; then
                    echo "Error: question.options[$i].description must be a string" >&2
                    return 1
                fi
            fi

            # Check for unknown fields in option
            local unknown
            unknown=$(echo "$option" | jq -r 'keys - ["label","value","description"] | .[0] // ""')
            if [[ -n "$unknown" ]]; then
                echo "Error: question.options[$i] has unknown field '$unknown'" >&2
                return 1
            fi

            i=$((i + 1))
        done
    fi

    # Validate timeout if present (must be positive integer)
    local timeout
    timeout=$(echo "$payload" | jq '.timeout // null')
    if [[ "$timeout" != "null" ]]; then
        if ! echo "$timeout" | grep -qE '^[1-9][0-9]*$'; then
            echo "Error: question.timeout must be a positive integer" >&2
            return 1
        fi
    fi

    # Check for unknown fields in question signal
    local unknown
    unknown=$(echo "$payload" | jq -r 'keys - ["question","questionType","options","timeout"] | .[0] // ""')
    if [[ -n "$unknown" ]]; then
        echo "Error: question signal has unknown field '$unknown'" >&2
        return 1
    fi

    return 0
}

# =============================================================================
# Data Signal Validators (existing)
# =============================================================================

validate_complete() {
    local payload="$1"

    # Must be an object
    if ! echo "$payload" | jq -e 'type == "object"' >/dev/null 2>&1; then
        echo "Error: complete signal must be a JSON object" >&2
        return 1
    fi

    # Validate taskId if present (should be string)
    if echo "$payload" | jq -e 'has("taskId")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.taskId | type == "string"' >/dev/null 2>&1; then
            echo "Error: complete.taskId must be a string" >&2
            return 1
        fi
    fi

    # Validate agentName if present (should be string)
    if echo "$payload" | jq -e 'has("agentName")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.agentName | type == "string"' >/dev/null 2>&1; then
            echo "Error: complete.agentName must be a string" >&2
            return 1
        fi
    fi

    # Validate summary if present (array of strings)
    if echo "$payload" | jq -e 'has("summary")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.summary | type == "array"' >/dev/null 2>&1; then
            echo "Error: complete.summary must be an array" >&2
            return 1
        fi
        if ! echo "$payload" | jq -e '.summary | all(type == "string")' >/dev/null 2>&1; then
            echo "Error: complete.summary must contain only strings" >&2
            return 1
        fi
    fi

    # Validate quality if present
    if echo "$payload" | jq -e 'has("quality")' >/dev/null 2>&1; then
        local quality
        quality=$(echo "$payload" | jq '.quality')
        if ! echo "$quality" | jq -e 'type == "object"' >/dev/null 2>&1; then
            echo "Error: complete.quality must be an object" >&2
            return 1
        fi
        validate_quality_signals "$quality" "complete." || return 1
    fi

    # Validate humanActions if present (reuse action validation)
    if echo "$payload" | jq -e 'has("humanActions")' >/dev/null 2>&1; then
        if ! echo "$payload" | jq -e '.humanActions | type == "array"' >/dev/null 2>&1; then
            echo "Error: complete.humanActions must be an array" >&2
            return 1
        fi
        local count
        count=$(echo "$payload" | jq '.humanActions | length')
        local i=0
        while [[ $i -lt $count ]]; do
            local action
            action=$(echo "$payload" | jq ".humanActions[$i]")

            # Validate each action
            if ! echo "$action" | jq -e 'has("title")' >/dev/null 2>&1; then
                echo "Error: complete.humanActions[$i] missing required field 'title'" >&2
                return 1
            fi

            local title
            title=$(echo "$action" | jq -r '.title // ""')
            if [[ -z "$title" ]]; then
                echo "Error: complete.humanActions[$i].title cannot be empty" >&2
                return 1
            fi

            i=$((i + 1))
        done
    fi

    # Validate suggestedTasks if present (reuse task validation)
    if echo "$payload" | jq -e 'has("suggestedTasks")' >/dev/null 2>&1; then
        local tasks
        tasks=$(echo "$payload" | jq '.suggestedTasks')
        if ! echo "$tasks" | jq -e 'type == "array"' >/dev/null 2>&1; then
            echo "Error: complete.suggestedTasks must be an array" >&2
            return 1
        fi
        # Validate each task (but with complete. prefix in errors)
        local count
        count=$(echo "$tasks" | jq 'length')
        local i=0
        while [[ $i -lt $count ]]; do
            local task
            task=$(echo "$tasks" | jq ".[$i]")

            if ! echo "$task" | jq -e 'has("title")' >/dev/null 2>&1; then
                echo "Error: complete.suggestedTasks[$i] missing required field 'title'" >&2
                return 1
            fi

            local title
            title=$(echo "$task" | jq -r '.title // ""')
            if [[ -z "$title" ]]; then
                echo "Error: complete.suggestedTasks[$i].title cannot be empty" >&2
                return 1
            fi

            i=$((i + 1))
        done
    fi

    # Validate crossAgentIntel if present
    if echo "$payload" | jq -e 'has("crossAgentIntel")' >/dev/null 2>&1; then
        local intel
        intel=$(echo "$payload" | jq '.crossAgentIntel')
        if ! echo "$intel" | jq -e 'type == "object"' >/dev/null 2>&1; then
            echo "Error: complete.crossAgentIntel must be an object" >&2
            return 1
        fi
        validate_cross_agent_intel "$intel" "complete." || return 1
    fi

    # Check for unknown fields
    local unknown
    unknown=$(echo "$payload" | jq -r 'keys - ["taskId","agentName","summary","quality","humanActions","suggestedTasks","crossAgentIntel"] | .[0] // ""')
    if [[ -n "$unknown" ]]; then
        echo "Error: complete has unknown field '$unknown'" >&2
        return 1
    fi

    return 0
}

# Run validation based on signal type
case "$SIGNAL_TYPE" in
    # Data signals
    tasks)
        validate_tasks "$PAYLOAD"
        ;;
    action)
        validate_action "$PAYLOAD"
        ;;
    complete)
        validate_complete "$PAYLOAD"
        ;;
    # Rich state signals
    working)
        validate_working "$PAYLOAD"
        ;;
    review)
        validate_review "$PAYLOAD"
        ;;
    needs_input)
        validate_needs_input "$PAYLOAD"
        ;;
    idle)
        validate_idle "$PAYLOAD"
        ;;
    completing)
        validate_completing "$PAYLOAD"
        ;;
    completed)
        validate_completed "$PAYLOAD"
        ;;
    starting)
        validate_starting "$PAYLOAD"
        ;;
    compacting)
        validate_compacting "$PAYLOAD"
        ;;
    auto_proceed)
        validate_auto_proceed "$PAYLOAD"
        ;;
    question)
        validate_question "$PAYLOAD"
        ;;
    *)
        echo "Error: Unknown signal type '$SIGNAL_TYPE'" >&2
        echo "Valid data types: tasks, action, complete" >&2
        echo "Valid rich state types: working, review, needs_input, idle, completing, completed, starting, compacting, auto_proceed, question" >&2
        exit 2
        ;;
esac

exit $?
