#!/bin/bash

# JAT CLI - Jomarchy Agent Tools
# Launch complete dev environments with Hyprland colored borders

set -e

# Config location
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/jat"
CONFIG_FILE="$CONFIG_DIR/projects.json"

# JAT source directory (detect where jat is installed)
# Priority: JAT_INSTALL_DIR env > XDG standard > ~/code/jat > follow symlink
detect_jat_source_dir() {
    if [[ -n "$JAT_INSTALL_DIR" ]] && [[ -d "$JAT_INSTALL_DIR/.git" ]]; then
        echo "$JAT_INSTALL_DIR"
    elif [[ -d "${XDG_DATA_HOME:-$HOME/.local/share}/jat/.git" ]]; then
        echo "${XDG_DATA_HOME:-$HOME/.local/share}/jat"
    elif [[ -d "$HOME/code/jat/.git" ]]; then
        echo "$HOME/code/jat"
    else
        # Follow the symlink from this script to find source
        local script_path
        script_path=$(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || echo "")
        if [[ -n "$script_path" ]]; then
            # Script is at PROJECT_ROOT/cli/jat, so go up two levels
            local project_root
            project_root=$(dirname "$(dirname "$script_path")")
            if [[ -d "$project_root/.git" ]]; then
                echo "$project_root"
                return
            fi
        fi
        # Fallback
        echo "$HOME/.local/share/jat"
    fi
}

JAT_SOURCE_DIR="$(detect_jat_source_dir)"

# Update check file (stores last check timestamp)
UPDATE_CHECK_FILE="$CONFIG_DIR/.last_update_check"

# Colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# Default terminal (can be overridden in config)
TERMINAL="${JAT_TERMINAL:-alacritty}"

#------------------------------------------------------------------------------
# Config Management
#------------------------------------------------------------------------------

ensure_config() {
    if [[ ! -d "$CONFIG_DIR" ]]; then
        mkdir -p "$CONFIG_DIR"
    fi

    if [[ ! -f "$CONFIG_FILE" ]]; then
        # Create default config
        cat > "$CONFIG_FILE" << 'EOF'
{
  "projects": {},
  "defaults": {
    "terminal": "alacritty",
    "editor": "code",
    "tools_path": "~/.local/bin",
    "claude_flags": "--dangerously-skip-permissions"
  }
}
EOF
        echo -e "${GREEN}Created config: $CONFIG_FILE${NC}"
    fi
}

get_project_config() {
    local project="$1"
    jq -r ".projects[\"$project\"] // empty" "$CONFIG_FILE"
}

list_projects() {
    jq -r '.projects | keys[]' "$CONFIG_FILE" 2>/dev/null
}

#------------------------------------------------------------------------------
# Self-Update Functions
#------------------------------------------------------------------------------

# Check if updates are available (origin/master has commits we don't have)
check_for_updates() {
    if [[ ! -d "$JAT_SOURCE_DIR/.git" ]]; then
        return 1  # Not a git repo
    fi

    # Fetch latest from remote (quietly)
    git -C "$JAT_SOURCE_DIR" fetch origin master --quiet 2>/dev/null || return 1

    # Check if origin/master has commits that HEAD doesn't have
    # This correctly handles the case where local is ahead of origin
    local behind
    behind=$(git -C "$JAT_SOURCE_DIR" rev-list HEAD..origin/master --count 2>/dev/null || echo "0")

    if [[ "$behind" -gt 0 ]]; then
        return 0  # Updates available
    fi
    return 1  # No updates (either up-to-date or ahead of origin)
}

# Get number of commits behind
get_commits_behind() {
    git -C "$JAT_SOURCE_DIR" rev-list HEAD..origin/master --count 2>/dev/null || echo "0"
}

# Perform the update
do_update() {
    local verbose="${1:-false}"

    if [[ ! -d "$JAT_SOURCE_DIR/.git" ]]; then
        echo -e "${RED}Error: JAT installation not found or not a git repository${NC}"
        echo ""
        echo "Checked locations:"
        echo "  - ${XDG_DATA_HOME:-$HOME/.local/share}/jat"
        echo "  - $HOME/code/jat"
        echo ""
        echo "JAT must be installed via git clone for auto-updates to work."
        echo "Reinstall with: curl -fsSL https://raw.githubusercontent.com/joewinke/jat/master/install.sh | bash"
        return 1
    fi

    echo -e "${BLUE}Updating JAT...${NC}"
    echo -e "${DIM}Source: $JAT_SOURCE_DIR${NC}"

    # Check for local changes
    if ! git -C "$JAT_SOURCE_DIR" diff-index --quiet HEAD -- 2>/dev/null; then
        echo -e "${YELLOW}Warning: You have local changes in $JAT_SOURCE_DIR${NC}"
        echo -e "${DIM}Stashing changes before update...${NC}"
        git -C "$JAT_SOURCE_DIR" stash --quiet
        local stashed=true
    fi

    # Pull latest changes
    echo -e "${DIM}Pulling latest changes...${NC}"
    if ! git -C "$JAT_SOURCE_DIR" pull origin master --quiet 2>&1; then
        echo -e "${RED}Error: Failed to pull updates${NC}"
        if [[ "${stashed:-}" == "true" ]]; then
            git -C "$JAT_SOURCE_DIR" stash pop --quiet 2>/dev/null
        fi
        return 1
    fi

    # Re-run symlink script to update symlinks (quietly)
    echo -e "${DIM}Updating symlinks...${NC}"
    if [[ -f "$JAT_SOURCE_DIR/tools/scripts/symlink-tools.sh" ]]; then
        bash "$JAT_SOURCE_DIR/tools/scripts/symlink-tools.sh" &>/dev/null || true
    fi

    # Restore stashed changes if any
    if [[ "${stashed:-}" == "true" ]]; then
        echo -e "${DIM}Restoring local changes...${NC}"
        git -C "$JAT_SOURCE_DIR" stash pop --quiet 2>/dev/null || true
    fi

    # Update the check timestamp
    date +%s > "$UPDATE_CHECK_FILE"

    # Show what was updated
    local new_version
    new_version=$(git -C "$JAT_SOURCE_DIR" log -1 --format='%h - %s' 2>/dev/null)
    echo ""
    echo -e "${GREEN}âœ“ JAT updated successfully${NC}"
    echo -e "${DIM}Latest: $new_version${NC}"
    echo ""
}

# Check if we should auto-check for updates (once per 24 hours)
should_check_for_updates() {
    # Check if auto-update is disabled in config
    local auto_update
    auto_update=$(jq -r '.defaults.auto_update // true' "$CONFIG_FILE" 2>/dev/null)
    if [[ "$auto_update" == "false" ]]; then
        return 1
    fi

    # Check last update time
    if [[ ! -f "$UPDATE_CHECK_FILE" ]]; then
        return 0  # Never checked, should check
    fi

    local last_check now diff
    last_check=$(cat "$UPDATE_CHECK_FILE" 2>/dev/null || echo "0")
    now=$(date +%s)
    diff=$((now - last_check))

    # Check at most once per 24 hours (86400 seconds)
    if [[ $diff -gt 86400 ]]; then
        return 0  # Should check
    fi
    return 1  # Already checked recently
}

# Interactive update check - prompts user if update available
# Only call this on IDE launch, not every command
interactive_update_check() {
    # Only run if we should check (respects auto_update setting and 24h throttle)
    should_check_for_updates || return 0

    # Update timestamp to prevent repeated checks
    date +%s > "$UPDATE_CHECK_FILE"

    # Check if JAT source exists
    if [[ ! -d "$JAT_SOURCE_DIR/.git" ]]; then
        return 0
    fi

    echo -e "${DIM}Checking for updates...${NC}"

    # Check for updates (this does a git fetch)
    if check_for_updates; then
        local commits_behind
        commits_behind=$(get_commits_behind)

        if [[ "$commits_behind" -gt 0 ]]; then
            echo ""
            echo -e "${YELLOW}JAT update available (${commits_behind} new commit(s)).${NC} Update now? [y/N] \c"

            # Read with timeout (5 seconds)
            local response
            read -t 5 -r response || response=""

            if [[ "$response" =~ ^[Yy]$ ]]; then
                do_update
            else
                echo -e "${DIM}Skipped. Run 'jat update' later to update.${NC}"
                echo ""
            fi
        fi
    else
        # Clear the "checking" message
        echo -e "${DIM}Up to date.${NC}"
    fi
}

# Manual update command
update_cmd() {
    local subcmd="${1:-}"

    case "$subcmd" in
        --check|-c)
            # Just check, don't update
            echo -e "${DIM}Checking for updates...${NC}"
            if check_for_updates; then
                local commits_behind
                commits_behind=$(get_commits_behind)
                echo -e "${GREEN}Update available: $commits_behind new commit(s)${NC}"
                echo ""
                echo "Run 'jat update' to update."
            else
                echo -e "${GREEN}âœ“ JAT is up to date${NC}"
            fi
            ;;
        --disable)
            # Disable auto-updates
            local tmp_file
            tmp_file=$(mktemp)
            jq '.defaults.auto_update = false' "$CONFIG_FILE" > "$tmp_file"
            mv "$tmp_file" "$CONFIG_FILE"
            echo -e "${GREEN}âœ“ Auto-updates disabled${NC}"
            echo "You can still manually update with: jat update"
            ;;
        --enable)
            # Enable auto-updates
            local tmp_file
            tmp_file=$(mktemp)
            jq '.defaults.auto_update = true' "$CONFIG_FILE" > "$tmp_file"
            mv "$tmp_file" "$CONFIG_FILE"
            echo -e "${GREEN}âœ“ Auto-updates enabled${NC}"
            ;;
        --status|-s)
            # Show installation status
            echo ""
            echo -e "${BOLD}JAT Installation Status${NC}"
            echo ""
            echo -e "  ${DIM}Install path:${NC} $JAT_SOURCE_DIR"
            if [[ -d "$JAT_SOURCE_DIR/.git" ]]; then
                local current_version branch
                current_version=$(git -C "$JAT_SOURCE_DIR" log -1 --format='%h' 2>/dev/null)
                branch=$(git -C "$JAT_SOURCE_DIR" branch --show-current 2>/dev/null)
                echo -e "  ${DIM}Git branch:${NC}   $branch"
                echo -e "  ${DIM}Version:${NC}      $current_version"
                echo -e "  ${DIM}Last commit:${NC}  $(git -C "$JAT_SOURCE_DIR" log -1 --format='%s' 2>/dev/null)"
            else
                echo -e "  ${YELLOW}Not a git repository - updates disabled${NC}"
            fi
            local auto_update
            auto_update=$(jq -r '.defaults.auto_update // true' "$CONFIG_FILE" 2>/dev/null)
            echo -e "  ${DIM}Auto-check:${NC}   $auto_update"
            echo ""
            ;;
        --help|-h)
            echo ""
            echo -e "${BOLD}JAT Update${NC}"
            echo ""
            echo "Keep JAT up to date with the latest features and fixes."
            echo ""
            echo -e "${DIM}Usage:${NC}"
            echo "  jat update           Pull latest updates"
            echo "  jat update --check   Check for updates without installing"
            echo "  jat update --status  Show installation path and version"
            echo "  jat update --disable Disable update checks on IDE launch"
            echo "  jat update --enable  Enable update checks on IDE launch"
            echo ""
            echo -e "${DIM}Update behavior:${NC}"
            echo "  When you launch the IDE with 'jat', it checks for updates"
            echo "  (at most once per 24 hours). If updates are available, you'll be"
            echo "  prompted: 'Update now? [y/N]'. Updates are never auto-installed."
            echo ""
            ;;
        "")
            # Perform update
            do_update
            ;;
        *)
            echo -e "${RED}Unknown update option: $subcmd${NC}"
            echo "Run 'jat update --help' for usage"
            return 1
            ;;
    esac
}

#------------------------------------------------------------------------------
# Hyprland Window Coloring
#------------------------------------------------------------------------------

apply_border_color() {
    local title_prefix="$1"
    local active_color="$2"
    local inactive_color="$3"

    if ! command -v hyprctl &>/dev/null; then
        return 0  # Skip if not on Hyprland
    fi

    # Find all windows with matching title prefix and apply colors using setprop
    # This uses hyprctl dispatch setprop which is the correct API for Hyprland 0.52+
    local clients
    clients=$(hyprctl clients -j 2>/dev/null) || return 0

    echo "$clients" | jq -r --arg prefix "$title_prefix" \
        '.[] | select(.title | startswith($prefix)) | .address' | \
    while read -r address; do
        [[ -z "$address" ]] && continue

        # Apply active border color
        if [[ -n "$active_color" ]]; then
            hyprctl dispatch setprop "address:$address" activebordercolor "$active_color" &>/dev/null || true
        fi

        # Apply inactive border color
        if [[ -n "$inactive_color" ]]; then
            hyprctl dispatch setprop "address:$address" inactivebordercolor "$inactive_color" &>/dev/null || true
        fi
    done
}

apply_all_colors() {
    local projects
    projects=$(list_projects)

    for project in $projects; do
        local config
        config=$(get_project_config "$project")
        local name active_color inactive_color
        name=$(echo "$config" | jq -r '.name')
        active_color=$(echo "$config" | jq -r '.active_color // empty')
        inactive_color=$(echo "$config" | jq -r '.inactive_color // empty')

        if [[ -n "$active_color" ]]; then
            apply_border_color "$name:" "$active_color" "$inactive_color"
        fi
    done
    echo -e "${GREEN}Applied colors to all project windows${NC}"
}

#------------------------------------------------------------------------------
# Launch Functions
#------------------------------------------------------------------------------

launch_code() {
    local path="$1"
    local name="$2"

    echo -e "${DIM}  â†’ VS Code${NC}"
    code --new-window "$path" &
}

launch_claude() {
    local path="$1"
    local name="$2"
    local db_url="$3"
    local tools_path="$4"
    local count="${5:-1}"
    local skip_agent="${6:-false}"
    local auto_mode="${7:-false}"

    # Build environment
    local env_vars="PATH=$PATH:$tools_path:$path/.claude/tools"
    env_vars="$env_vars AGENT_MAIL_URL=http://localhost:8765"
    [[ -n "$db_url" ]] && env_vars="$env_vars DATABASE_URL=$db_url"

    # Get claude flags from config
    local claude_flags
    claude_flags=$(jq -r '.defaults.claude_flags // "--dangerously-skip-permissions"' "$CONFIG_FILE")

    # JAT bootstrap prompt - minimal identity, commands load full docs on-demand
    local jat_bootstrap='You are a JAT agent. Run /jat:start to begin work.'
    claude_flags="$claude_flags --append-system-prompt '$jat_bootstrap'"

    # Build initial prompt (without -p flag which makes it non-interactive)
    local initial_prompt=""
    if [[ "$skip_agent" != "true" ]]; then
        if [[ "$auto_mode" == "true" ]]; then
            initial_prompt="/jat:start auto"
        else
            initial_prompt="/jat:start"
        fi
    fi

    # Launch N Claude sessions with staggered timing
    # Each session runs inside tmux so IDE can track it
    for ((i=1; i<=count; i++)); do
        local window_title
        if [[ $count -eq 1 ]]; then
            window_title="$name: Claude"
            echo -e "${DIM}  â†’ Claude Code${NC}"
        else
            window_title="$name: Claude #$i"
            echo -e "${DIM}  â†’ Claude Code #$i${NC}"
        fi

        # Create unique session name using PID + counter
        # /jat:start will rename to jat-{AgentName} after registration
        local session_name="jat-pending-$$-$i"

        # Create logs directory if it doesn't exist
        local logs_dir="$path/.beads/logs"
        mkdir -p "$logs_dir"

        # Log file starts with session name, will be renamed when task is claimed
        local log_file="$logs_dir/session-${session_name}-$(date +%Y%m%d-%H%M%S).log"

        # Launch terminal with tmux session containing Claude
        # This allows IDE to track the session via tmux
        # Use -x 120 to ensure ANSI boxes don't wrap (default is 80 columns)
        # Capture scrollback buffer on exit (not pipe-pane which logs every redraw)
        $TERMINAL -T "$window_title" -e bash -c "
            cd '$path'
            tmux new-session -d -s '$session_name' -x 120 -y 40 -c '$path'
            # Set large scrollback buffer to capture full session history
            tmux set-option -t '$session_name' history-limit 50000
            # Wait for shell to initialize before sending keys
            # Without this delay, the shell may not be ready and keys are lost
            sleep 0.3
            tmux send-keys -t '$session_name' '$env_vars claude $claude_flags \"$initial_prompt\"' Enter
            tmux attach-session -t '$session_name'
            # After detach/exit, capture the scrollback buffer to log file
            tmux capture-pane -t '$session_name' -p -S -50000 > \"$log_file\" 2>/dev/null || true
        " &

        # Stagger launches so each agent sees previous agents' reservations
        if [[ $i -lt $count ]]; then
            local stagger
            stagger=$(jq -r '.defaults.agent_stagger // 15' "$CONFIG_FILE")
            sleep "$stagger"
        fi
    done
}

launch_npm() {
    local path="$1"
    local name="$2"
    local port="$3"

    if [[ -z "$port" ]]; then
        echo -e "${YELLOW}  âŠ˜ No dev server port configured${NC}"
        return 0
    fi

    echo -e "${DIM}  â†’ Dev Server :$port${NC}"
    $TERMINAL -T "$name: Dev Server :$port" -e bash -c "cd '$path' && npm run dev -- --port $port; exec bash" &
}

launch_browser() {
    local port="$1"
    local name="$2"

    if [[ -z "$port" ]]; then
        echo -e "${YELLOW}  âŠ˜ No port configured for browser${NC}"
        return 0
    fi

    echo -e "${DIM}  â†’ Browser http://localhost:$port${NC}"

    # Wait for server to start
    (
        sleep 2
        if command -v xdg-open &>/dev/null; then
            xdg-open "http://localhost:$port" &>/dev/null
        elif command -v open &>/dev/null; then
            open "http://localhost:$port"
        fi
    ) &
}

launch_ide() {
    local name="$1"
    local ide_port="${2:-3333}"
    local ide_path="$JAT_SOURCE_DIR/ide"

    # Check if IDE directory exists
    if [[ ! -d "$ide_path" ]]; then
        echo -e "${YELLOW}  âŠ˜ IDE not found: $ide_path${NC}"
        return 0
    fi

    # Detect if HTTPS is enabled (certs exist in ide/certs/)
    local ide_protocol="http"
    if [[ -f "$ide_path/certs/localhost.pem" ]] && [[ -f "$ide_path/certs/localhost-key.pem" ]]; then
        ide_protocol="https"
    fi

    # Use server-jat prefix so the /api/servers endpoint can find it
    local session_name="server-jat"

    # Kill existing IDE server session before spawning new terminal
    # This allows running `jat` to reset/restart the IDE server
    if tmux has-session -t "$session_name" 2>/dev/null; then
        echo -e "${DIM}  â†’ Stopping existing IDE server...${NC}"
        tmux kill-session -t "$session_name" 2>/dev/null || true
    fi

    # Also kill any orphaned process on the port (tmux kill-session can leave orphans)
    fuser -k "$ide_port/tcp" 2>/dev/null || true

    echo -e "${DIM}  â†’ IDE ${ide_protocol}://localhost:$ide_port${NC}"

    # Clear Vite cache to prevent stale chunk errors
    rm -rf "$ide_path/.svelte-kit" "$ide_path/node_modules/.vite" 2>/dev/null

    # Launch IDE dev server inside a tmux session
    # This allows the attach feature to work with tmux windows
    $TERMINAL -T "$name: IDE :$ide_port" -e bash -c "
        cd '$ide_path'
        tmux new-session -d -s '$session_name' -x 120 -y 40 -c '$ide_path'
        # Wait for shell to initialize
        sleep 0.3
        tmux send-keys -t '$session_name' 'npm run dev -- --port $ide_port' Enter
        tmux attach-session -t '$session_name'
    " &

    # Open browser after delay for server to start
    (
        sleep 3
        if command -v xdg-open &>/dev/null; then
            xdg-open "${ide_protocol}://localhost:$ide_port" &>/dev/null
        elif command -v open &>/dev/null; then
            open "${ide_protocol}://localhost:$ide_port"
        fi
    ) &
}

launch_project() {
    local project="$1"
    shift

    # Parse options
    local do_all=true
    local do_code=false
    local do_claude=false
    local do_npm=false
    local do_browser=false
    local do_ide=false
    local session_count=1
    local skip_agent=false
    local skip_ide=false
    local auto_mode=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --code|-c)       do_all=false; do_code=true ;;
            --claude|-l)     do_all=false; do_claude=true ;;
            --npm|-n)        do_all=false; do_npm=true ;;
            --browser|-b)    do_all=false; do_browser=true ;;
            --ide|-i)        do_all=false; do_ide=true ;;
            --all|-a)        do_all=true ;;
            --no-agent)      skip_agent=true ;;
            --no-ide)        skip_ide=true ;;
            --auto)          auto_mode=true ;;
            [0-9]*)          session_count="$1" ;;
            *) echo -e "${RED}Unknown option: $1${NC}"; return 1 ;;
        esac
        shift
    done

    # Get project config
    local config
    config=$(get_project_config "$project")

    if [[ -z "$config" ]]; then
        echo -e "${RED}Unknown project: $project${NC}"
        echo ""
        echo "Available projects:"
        list_projects | while read -r p; do
            echo "  â€¢ $p"
        done
        echo ""
        echo "Add a project with: jat init"
        return 1
    fi

    # Parse config
    local name path port db_url active_color inactive_color tools_path
    name=$(echo "$config" | jq -r '.name')
    path=$(echo "$config" | jq -r '.path' | sed "s|^~|$HOME|")
    port=$(echo "$config" | jq -r '.port // empty')
    db_url=$(echo "$config" | jq -r '.database_url // empty')
    active_color=$(echo "$config" | jq -r '.active_color // empty')
    inactive_color=$(echo "$config" | jq -r '.inactive_color // empty')
    tools_path=$(jq -r '.defaults.tools_path // "~/.local/bin"' "$CONFIG_FILE" | sed "s|^~|$HOME|")

    # Verify path exists
    if [[ ! -d "$path" ]]; then
        echo -e "${RED}Project path does not exist: $path${NC}"
        return 1
    fi

    echo ""
    echo -e "${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${BOLD}â•‘  ${CYAN}ðŸš€ Launching: ${name}${NC}${BOLD}                                        â•‘${NC}"
    echo -e "${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    echo -e "  ${DIM}Path:${NC} $path"
    [[ -n "$port" ]] && echo -e "  ${DIM}Port:${NC} $port"
    [[ -n "$active_color" ]] && echo -e "  ${DIM}Color:${NC} $active_color"
    [[ $session_count -gt 1 ]] && echo -e "  ${DIM}Sessions:${NC} $session_count"
    echo ""

    # Launch components
    # Order: npm/browser/IDE first (need time to start), then Claude sessions last
    if $do_all; then
        launch_code "$path" "$name"
        sleep 0.3
        launch_npm "$path" "$name" "$port"
        launch_browser "$port" "$name"
        # Launch IDE unless --no-ide was specified
        if [[ "$skip_ide" != "true" ]]; then
            sleep 0.3
            launch_ide "$name"
        fi
        # Launch Claude sessions last (gives servers time to start)
        sleep 0.3
        launch_claude "$path" "$name" "$db_url" "$tools_path" "$session_count" "$skip_agent" "$auto_mode"
    else
        $do_code && launch_code "$path" "$name"
        $do_claude && launch_claude "$path" "$name" "$db_url" "$tools_path" "$session_count" "$skip_agent" "$auto_mode"
        $do_npm && launch_npm "$path" "$name" "$port"
        $do_browser && launch_browser "$port" "$name"
        $do_ide && launch_ide "$name"
    fi

    # Apply Hyprland colors
    if [[ -n "$active_color" ]]; then
        (sleep 1.5 && apply_border_color "$name:" "$active_color" "$inactive_color") &
    fi

    echo ""
    echo -e "${GREEN}âœ“ Environment launched${NC}"
}

#------------------------------------------------------------------------------
# Init / Setup
#------------------------------------------------------------------------------

init_projects() {
    echo -e "${BOLD}Scanning ~/code for projects...${NC}"
    echo ""

    local code_dir="$HOME/code"
    local added=0

    for repo_dir in "$code_dir"/*; do
        [[ ! -d "$repo_dir" ]] && continue
        [[ ! -d "$repo_dir/.git" ]] && continue

        local repo_name
        repo_name=$(basename "$repo_dir")

        # Check if already configured
        if [[ -n "$(get_project_config "$repo_name")" ]]; then
            echo -e "  ${DIM}âœ“ $repo_name (already configured)${NC}"
            continue
        fi

        # Auto-detect port from package.json if exists
        local port=""
        if [[ -f "$repo_dir/package.json" ]]; then
            # Try to find a port in scripts
            port=$(jq -r '.scripts.dev // ""' "$repo_dir/package.json" 2>/dev/null | grep -oE -- '--port[= ]+[0-9]+' | grep -oE '[0-9]+' | head -1 || true)
        fi

        # Generate a color based on repo name hash
        local hash
        hash=$(echo -n "$repo_name" | md5sum | cut -c1-6)
        local r=$((16#${hash:0:2}))
        local g=$((16#${hash:2:2}))
        local b=$((16#${hash:4:2}))
        local active_color="rgb($(printf '%02x%02x%02x' $r $g $b))"
        local inactive_color="rgb($(printf '%02x%02x%02x' $((r*3/4)) $((g*3/4)) $((b*3/4))))"

        # Add to config
        local new_project
        new_project=$(cat << EOF
{
  "name": "${repo_name^^}",
  "path": "~/code/$repo_name",
  "port": ${port:-null},
  "database_url": null,
  "active_color": "$active_color",
  "inactive_color": "$inactive_color"
}
EOF
)

        # Update config file
        local tmp_file
        tmp_file=$(mktemp)
        jq ".projects[\"$repo_name\"] = $new_project" "$CONFIG_FILE" > "$tmp_file"
        mv "$tmp_file" "$CONFIG_FILE"

        echo -e "  ${GREEN}+ $repo_name${NC}"
        added=$((added + 1))
    done

    echo ""
    if [[ $added -gt 0 ]]; then
        echo -e "${GREEN}Added $added project(s) to config${NC}"
    else
        echo -e "${DIM}No new projects found${NC}"
    fi
    echo ""
    echo "Edit config: $CONFIG_FILE"
}

add_project() {
    local project_path="$1"
    local project_name="$2"

    if [[ -z "$project_path" ]]; then
        echo -e "${RED}Usage: jat add <path> [name]${NC}"
        echo ""
        echo "Examples:"
        echo "  jat add ~/projects/my-app"
        echo "  jat add ~/work/client-project client"
        echo "  jat add .                              # Add current directory"
        return 1
    fi

    # Handle "." as current directory
    if [[ "$project_path" == "." ]]; then
        project_path="$(pwd)"
    fi

    # Expand ~ and resolve to absolute path
    project_path="${project_path/#\~/$HOME}"
    project_path="$(cd "$project_path" 2>/dev/null && pwd)" || {
        echo -e "${RED}Error: Cannot access directory: $1${NC}"
        return 1
    }

    # Check if it's a git repo
    if [[ ! -d "$project_path/.git" ]]; then
        echo -e "${YELLOW}Warning: Not a git repository: $project_path${NC}"
        echo -e "${DIM}Continuing anyway...${NC}"
    fi

    # Determine project name
    if [[ -z "$project_name" ]]; then
        project_name=$(basename "$project_path")
    fi

    # Check if already configured
    if [[ -n "$(get_project_config "$project_name")" ]]; then
        echo -e "${YELLOW}Project '$project_name' already configured${NC}"
        echo ""
        echo "To update, edit: $CONFIG_FILE"
        echo "Or remove first: jat remove $project_name"
        return 1
    fi

    # Auto-detect port from package.json if exists
    local port=""
    if [[ -f "$project_path/package.json" ]]; then
        port=$(jq -r '.scripts.dev // ""' "$project_path/package.json" 2>/dev/null | grep -oE -- '--port[= ]+[0-9]+' | grep -oE '[0-9]+' | head -1 || true)
    fi

    # Generate a color based on project name hash
    local hash
    hash=$(echo -n "$project_name" | md5sum | cut -c1-6)
    local r=$((16#${hash:0:2}))
    local g=$((16#${hash:2:2}))
    local b=$((16#${hash:4:2}))
    local active_color="rgb($(printf '%02x%02x%02x' $r $g $b))"
    local inactive_color="rgb($(printf '%02x%02x%02x' $((r*3/4)) $((g*3/4)) $((b*3/4))))"

    # Convert path back to use ~ for storage
    local stored_path="${project_path/#$HOME/\~}"

    # Add to config
    local new_project
    new_project=$(cat << EOF
{
  "name": "${project_name^^}",
  "path": "$stored_path",
  "port": ${port:-null},
  "database_url": null,
  "active_color": "$active_color",
  "inactive_color": "$inactive_color"
}
EOF
)

    # Update config file
    local tmp_file
    tmp_file=$(mktemp)
    jq ".projects[\"$project_name\"] = $new_project" "$CONFIG_FILE" > "$tmp_file"
    mv "$tmp_file" "$CONFIG_FILE"

    echo ""
    echo -e "${GREEN}Added project: $project_name${NC}"
    echo -e "  ${DIM}Path:${NC} $stored_path"
    [[ -n "$port" ]] && echo -e "  ${DIM}Port:${NC} $port (auto-detected)"
    echo -e "  ${DIM}Color:${NC} $active_color"
    echo ""
    echo "Launch with: jat $project_name"
    echo "Edit config: $CONFIG_FILE"
}

remove_project() {
    local project_name="$1"

    if [[ -z "$project_name" ]]; then
        echo -e "${RED}Usage: jat remove <project-name>${NC}"
        return 1
    fi

    # Check if exists
    if [[ -z "$(get_project_config "$project_name")" ]]; then
        echo -e "${RED}Project not found: $project_name${NC}"
        return 1
    fi

    # Remove from config
    local tmp_file
    tmp_file=$(mktemp)
    jq "del(.projects[\"$project_name\"])" "$CONFIG_FILE" > "$tmp_file"
    mv "$tmp_file" "$CONFIG_FILE"

    echo -e "${GREEN}Removed project: $project_name${NC}"
}

show_config() {
    local project="$1"

    if [[ -z "$project" ]]; then
        # Show all config
        cat "$CONFIG_FILE" | jq .
    else
        local config
        config=$(get_project_config "$project")
        if [[ -z "$config" ]]; then
            echo -e "${RED}Unknown project: $project${NC}"
            return 1
        fi
        echo "$config" | jq .
    fi
}

edit_config() {
    ${EDITOR:-vim} "$CONFIG_FILE"
}

#------------------------------------------------------------------------------
# List Projects - Helper Functions
#------------------------------------------------------------------------------

# Get task counts from Beads for a project path
get_project_tasks() {
    local project_path="$1"
    local beads_dir="$project_path/.beads"

    if [[ ! -d "$beads_dir" ]]; then
        echo "-"
        return
    fi

    # Count open and total tasks
    local total open
    total=$(find "$beads_dir" -name "*.json" -type f 2>/dev/null | wc -l)
    open=$(grep -l '"status": "open"\|"status": "in_progress"' "$beads_dir"/*.json 2>/dev/null | wc -l)

    if [[ "$total" -eq 0 ]]; then
        echo "-"
    else
        echo "${open}/${total}"
    fi
}

# Get count of active/total agents for a project
# Returns: "2/67" (2 active, 67 total) or "67" (all inactive) or "-" (none)
get_project_agents() {
    local project_path="$1"
    local claude_dir="$project_path/.claude"

    if [[ ! -d "$claude_dir" ]]; then
        echo "-"
        return
    fi

    # Count total agent files
    local total=0
    local active=0

    for agent_file in "$claude_dir"/agent-*.txt; do
        [[ ! -f "$agent_file" ]] && continue
        total=$((total + 1))

        # Check if agent is active (file modified in last 30 minutes)
        local mtime now diff
        mtime=$(stat -c %Y "$agent_file" 2>/dev/null || stat -f %m "$agent_file" 2>/dev/null)
        now=$(date +%s)
        diff=$((now - mtime))

        if [[ $diff -lt 1800 ]]; then  # 30 minutes
            active=$((active + 1))
        fi
    done

    if [[ $total -eq 0 ]]; then
        echo "-"
    elif [[ $active -gt 0 ]]; then
        echo "${active}/${total}"
    else
        echo "$total"
    fi
}

# Check if a port is in use (server running)
get_port_status() {
    local port="$1"

    if [[ -z "$port" ]] || [[ "$port" == "null" ]]; then
        echo "-"
        return
    fi

    # Check if port is listening
    if ss -tlnp 2>/dev/null | grep -q ":${port} " || \
       lsof -i ":${port}" -sTCP:LISTEN >/dev/null 2>&1; then
        echo -e "${GREEN}running${NC}"
    else
        echo "-"
    fi
}

# Get time since last activity in a project (returns timestamp and human readable)
# Usage: get_last_activity path [format]
#   format: "human" (default) returns "3m", "2h", etc.
#   format: "timestamp" returns unix timestamp for sorting
get_last_activity() {
    local project_path="$1"
    local format="${2:-human}"

    if [[ ! -d "$project_path" ]]; then
        [[ "$format" == "timestamp" ]] && echo "0" || echo "-"
        return
    fi

    # Get most recent modification time from git or files
    local last_mod
    if [[ -d "$project_path/.git" ]]; then
        # Use git log for last commit time
        last_mod=$(git -C "$project_path" log -1 --format="%ct" 2>/dev/null)
    fi

    if [[ -z "$last_mod" ]]; then
        # Fall back to directory mtime
        last_mod=$(stat -c %Y "$project_path" 2>/dev/null || stat -f %m "$project_path" 2>/dev/null)
    fi

    if [[ -z "$last_mod" ]]; then
        [[ "$format" == "timestamp" ]] && echo "0" || echo "-"
        return
    fi

    # Return timestamp for sorting
    if [[ "$format" == "timestamp" ]]; then
        echo "$last_mod"
        return
    fi

    # Format as human readable
    local now diff
    now=$(date +%s)
    diff=$((now - last_mod))

    if [[ $diff -lt 60 ]]; then
        echo "now"
    elif [[ $diff -lt 3600 ]]; then
        echo "$((diff / 60))m"
    elif [[ $diff -lt 86400 ]]; then
        echo "$((diff / 3600))h"
    else
        echo "$((diff / 86400))d"
    fi
}

# Truncate path for display
truncate_path() {
    local path="$1"
    local max_len="${2:-25}"

    # Replace $HOME with ~
    path="${path/#$HOME/\~}"

    if [[ ${#path} -le $max_len ]]; then
        echo "$path"
    else
        echo "...${path: -$((max_len - 3))}"
    fi
}

#------------------------------------------------------------------------------
# List Projects
#------------------------------------------------------------------------------

list_all() {
    ensure_config

    echo ""
    echo -e "${BOLD}Configured Projects:${NC}"
    echo ""

    local projects
    projects=$(list_projects)

    if [[ -z "$projects" ]]; then
        echo -e "  ${DIM}No projects configured${NC}"
        echo ""
        echo "  Run: jat init"
        return 0
    fi

    # Table header
    printf "  ${DIM}%-12s %-6s %-8s %-7s %-8s %-6s %-25s${NC}\n" \
        "PROJECT" "PORT" "TASKS" "AGENTS" "STATUS" "LAST" "PATH"
    printf "  ${DIM}%-12s %-6s %-8s %-7s %-8s %-6s %-25s${NC}\n" \
        "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

    # Collect project data with timestamps for sorting
    local project_data=""
    for project in $projects; do
        local config
        config=$(get_project_config "$project")

        local port path timestamp
        port=$(echo "$config" | jq -r '.port // empty')
        path=$(echo "$config" | jq -r '.path' | sed "s|^~|$HOME|")
        timestamp=$(get_last_activity "$path" "timestamp")

        # Store as: timestamp|project|port|path
        project_data+="${timestamp}|${project}|${port}|${path}"$'\n'
    done

    # Sort by timestamp descending (most recent first) and display
    echo "$project_data" | sort -t'|' -k1 -nr | while IFS='|' read -r timestamp project port path; do
        [[ -z "$project" ]] && continue

        local tasks agents status last_activity display_path
        tasks=$(get_project_tasks "$path")
        agents=$(get_project_agents "$path")
        status=$(get_port_status "$port")
        last_activity=$(get_last_activity "$path")
        display_path=$(truncate_path "$path" 25)

        # Format port display
        local port_display="${port:-"-"}"
        [[ "$port_display" == "null" ]] && port_display="-"

        printf "  %-12s %-6s %-8s %-7s %-8b %-6s %-25s\n" \
            "$project" "$port_display" "$tasks" "$agents" "$status" "$last_activity" "$display_path"
    done

    echo ""
    echo -e "${DIM}Usage: jat <project> [N] [--code|--claude|--npm|--browser|--no-agent]${NC}"
    echo ""
}

#------------------------------------------------------------------------------
# Help
#------------------------------------------------------------------------------

show_help() {
    cat << 'EOF'

JAT - AI Agent Task IDE

USAGE:
    jat                    Launch the IDE
    jat demo               Launch demo environment
    jat list               Show all projects
    jat init               Auto-detect projects in ~/code

QUICK START:
    jat init               Auto-detect and add projects
    jat                    Launch IDE to manage agents

PROJECT MANAGEMENT:
    init                   Auto-detect projects in ~/code
    add <path> [name]      Add a project
    remove <name>          Remove project
    list                   Show all projects with status

UPDATES:
    update                 Pull latest JAT updates
    update --check         Check for updates without installing
    update --status        Show installation path and version
    update --disable       Disable automatic update checks
    update --enable        Enable automatic update checks

DEMO MODE:
    demo                   Launch demo with sample projects
    demo setup             Fresh setup (cleans & recreates)
    demo on/off            Toggle demo visibility

SESSION MANAGEMENT:
    resume <agent>         Resume session by agent name (e.g., CrystalTundra)
    resume <id>            Resume session by ID (partial OK)
    resume --list          List recent sessions
    find-session <agent>   Find session ID for an agent
    -r                     Shortcut for resume
    -fs                    Shortcut for find-session

ADVANCED:
    cleanup                Remove stale agents
    config                 Show configuration

CONFIG: ~/.config/jat/projects.json

EOF
}

#------------------------------------------------------------------------------
# Cleanup Stale Agents
#------------------------------------------------------------------------------

cleanup_agents() {
    local dry_run=false
    [[ "$1" == "--dry-run" ]] && dry_run=true

    echo ""
    echo -e "${BOLD}Cleaning up stale agents...${NC}"
    echo ""

    local total_session_deleted=0
    local total_session_kept=0

    # =========================================================================
    # PART 1: Clean up session files (.claude/agent-*.txt)
    # =========================================================================
    echo -e "${DIM}Session files:${NC}"

    # Process each project
    for project in $(list_projects); do
        local config path claude_dir
        config=$(get_project_config "$project")
        path=$(echo "$config" | jq -r '.path' | sed "s|^~|$HOME|")
        claude_dir="$path/.claude"

        [[ ! -d "$claude_dir" ]] && continue

        local project_deleted=0
        local project_kept=0

        for agent_file in "$claude_dir"/agent-*.txt; do
            [[ ! -f "$agent_file" ]] && continue

            local agent_name session_id
            agent_name=$(cat "$agent_file" 2>/dev/null)
            session_id=$(basename "$agent_file" .txt | sed 's/agent-//')

            # Check if agent should be kept
            local keep=false
            local keep_reason=""

            # Check 1: Is the agent active (file modified in last 30 min)?
            local mtime now diff
            mtime=$(stat -c %Y "$agent_file" 2>/dev/null || stat -f %m "$agent_file" 2>/dev/null)
            now=$(date +%s)
            diff=$((now - mtime))
            if [[ $diff -lt 1800 ]]; then
                keep=true
                keep_reason="active session"
            fi

            # Check 2: Does the agent have ANY messages ever? (message history)
            if [[ "$keep" == "false" ]] && [[ -f "$db_path" ]]; then
                local agent_id_lookup message_count
                agent_id_lookup=$(sqlite3 "$db_path" "SELECT id FROM agents WHERE name = '$agent_name'" 2>/dev/null)
                if [[ -n "$agent_id_lookup" ]]; then
                    message_count=$(sqlite3 "$db_path" "SELECT COUNT(*) FROM message_recipients WHERE agent_id = $agent_id_lookup" 2>/dev/null || echo "0")
                    if [[ "$message_count" -gt 0 ]]; then
                        keep=true
                        keep_reason="has message history ($message_count messages)"
                    fi
                fi
            fi

            # Check 3: Does the agent have ANY tasks ever assigned in Beads? (task history)
            if [[ "$keep" == "false" ]] && command -v bd &>/dev/null; then
                local task_history
                task_history=$(bd list --json 2>/dev/null | jq -r --arg agent "$agent_name" \
                    '[.[] | select(.assignee == $agent)] | length' 2>/dev/null || echo "0")
                if [[ "$task_history" -gt 0 ]]; then
                    keep=true
                    keep_reason="has task history ($task_history tasks)"
                fi
            fi

            # Check 4: Does the agent have file reservations?
            if [[ "$keep" == "false" ]] && command -v am-reservations &>/dev/null; then
                local reservation_count
                reservation_count=$(am-reservations --agent "$agent_name" --json 2>/dev/null | jq 'length' 2>/dev/null || echo "0")
                if [[ "$reservation_count" -gt 0 ]]; then
                    keep=true
                    keep_reason="has $reservation_count file reservation(s)"
                fi
            fi

            if [[ "$keep" == "true" ]]; then
                project_kept=$((project_kept + 1))
                total_session_kept=$((total_session_kept + 1))
                if $dry_run; then
                    echo -e "  ${GREEN}[preserved]${NC} $agent_name - $keep_reason"
                fi
            else
                project_deleted=$((project_deleted + 1))
                total_session_deleted=$((total_session_deleted + 1))
                if $dry_run; then
                    echo -e "  ${YELLOW}[orphan]${NC} $agent_name - stale session file"
                else
                    rm -f "$agent_file"
                    echo -e "  ${RED}deleted${NC} $agent_name"
                fi
            fi
        done

        if [[ $project_deleted -gt 0 ]] || [[ $project_kept -gt 0 ]]; then
            if $dry_run; then
                echo -e "  ${DIM}$project: $project_deleted to delete, $project_kept to keep${NC}"
            fi
        fi
    done

    # =========================================================================
    # PART 2: Clean up Agent Mail database (~/.agent-mail.db)
    # =========================================================================
    echo ""
    echo -e "${DIM}Agent Mail database:${NC}"

    local db_path="$HOME/.agent-mail.db"
    local total_db_deleted=0
    local total_db_kept=0


    if [[ ! -f "$db_path" ]]; then
        echo -e "  ${DIM}No Agent Mail database found${NC}"
    else
        # Get all agents from Agent Mail database
        local agents_json
        agents_json=$(sqlite3 -json "$db_path" "SELECT id, name FROM agents ORDER BY name" 2>/dev/null)

        if [[ -z "$agents_json" ]] || [[ "$agents_json" == "[]" ]]; then
            echo -e "  ${DIM}No agents in database${NC}"
        else
            # Cache Beads tasks list once (avoid repeated calls)
            local beads_tasks=""
            if command -v bd &>/dev/null; then
                beads_tasks=$(bd list --json 2>/dev/null || echo "[]")
            fi

            # Cache session files list
            local session_agents=""
            for project in $(list_projects); do
                local config path
                config=$(get_project_config "$project")
                path=$(echo "$config" | jq -r '.path' | sed "s|^~|$HOME|")
                if [[ -d "$path/.claude" ]]; then
                    for f in "$path/.claude"/agent-*.txt; do
                        [[ -f "$f" ]] && session_agents+="$(cat "$f" 2>/dev/null)"$'\n'
                    done
                fi
            done

            # Process each agent using a for loop to avoid subshell issues
            local agent_ids agent_names
            agent_ids=$(echo "$agents_json" | jq -r '.[].id')
            agent_names=$(echo "$agents_json" | jq -r '.[].name')

            # Convert to arrays
            local -a ids=()
            local -a names=()
            while IFS= read -r id; do ids+=("$id"); done <<< "$agent_ids"
            while IFS= read -r name; do names+=("$name"); done <<< "$agent_names"

            local i
            for ((i=0; i<${#ids[@]}; i++)); do
                local agent_id="${ids[$i]}"
                local agent_name="${names[$i]}"

                [[ -z "$agent_id" ]] && continue
                [[ -z "$agent_name" ]] && continue

                # Check if agent should be kept
                local keep=false
                local keep_reason=""

                # Check 1: Does the agent have a session file anywhere? (active session)
                if [[ -n "$session_agents" ]] && echo "$session_agents" | grep -qF "$agent_name"; then
                    keep=true
                    keep_reason="active session"
                fi

                # Check 2: Does the agent have ANY messages ever? (message history)
                if [[ "$keep" == "false" ]]; then
                    local message_count
                    message_count=$(sqlite3 "$db_path" "SELECT COUNT(*) FROM message_recipients WHERE agent_id = $agent_id" 2>/dev/null || echo "0")
                    if [[ "$message_count" -gt 0 ]]; then
                        keep=true
                        keep_reason="has message history ($message_count messages)"
                    fi
                fi

                # Check 3: Does the agent have ANY tasks ever assigned in Beads? (task history)
                if [[ "$keep" == "false" ]] && [[ -n "$beads_tasks" ]] && [[ "$beads_tasks" != "[]" ]]; then
                    local task_history
                    task_history=$(echo "$beads_tasks" | jq -r --arg agent "$agent_name" \
                        '[.[] | select(.assignee == $agent)] | length' 2>/dev/null || echo "0")
                    if [[ "$task_history" -gt 0 ]]; then
                        keep=true
                        keep_reason="has task history ($task_history tasks)"
                    fi
                fi

                # Check 4: Does the agent have active file reservations?
                if [[ "$keep" == "false" ]]; then
                    local active_reservations
                    active_reservations=$(sqlite3 "$db_path" "SELECT COUNT(*) FROM file_reservations WHERE agent_id = $agent_id AND released_ts IS NULL AND expires_ts > datetime('now')" 2>/dev/null || echo "0")
                    if [[ "$active_reservations" -gt 0 ]]; then
                        keep=true
                        keep_reason="has $active_reservations active reservation(s)"
                    fi
                fi

                if [[ "$keep" == "true" ]]; then
                    total_db_kept=$((total_db_kept + 1))
                    if $dry_run; then
                        echo -e "  ${GREEN}[preserved]${NC} $agent_name - $keep_reason"
                    fi
                else
                    total_db_deleted=$((total_db_deleted + 1))
                    if $dry_run; then
                        echo -e "  ${YELLOW}[orphan]${NC} $agent_name - no session, no messages, no tasks"
                    else
                        # Delete agent and related records from Agent Mail database
                        sqlite3 "$db_path" "DELETE FROM message_recipients WHERE agent_id = $agent_id" 2>/dev/null
                        sqlite3 "$db_path" "DELETE FROM file_reservations WHERE agent_id = $agent_id" 2>/dev/null
                        sqlite3 "$db_path" "DELETE FROM agents WHERE id = $agent_id" 2>/dev/null
                        echo -e "  ${RED}deleted${NC} $agent_name"
                    fi
                fi
            done
        fi
    fi


    # =========================================================================
    # Summary
    # =========================================================================
    echo ""
    if $dry_run; then
        echo -e "${YELLOW}DRY RUN:${NC}"
        echo -e "  Session files: Would delete $total_session_deleted, keep $total_session_kept"
        echo -e "  Agent Mail DB: Would delete $total_db_deleted, keep $total_db_kept"
        echo ""
        echo "Run 'jat cleanup' to actually delete stale agents"
    else
        echo -e "${GREEN}Cleanup complete:${NC}"
        echo -e "  Session files: Deleted $total_session_deleted, kept $total_session_kept"
        echo -e "  Agent Mail DB: Deleted $total_db_deleted, kept $total_db_kept"
    fi
    echo ""
}

#------------------------------------------------------------------------------
# Install Git Hooks
#------------------------------------------------------------------------------

install_hooks() {
    local target="${1:-.}"

    # Resolve to absolute path
    target="$(cd "$target" 2>/dev/null && pwd)" || {
        echo -e "${RED}Error: Cannot access directory: $1${NC}" >&2
        return 1
    }

    # Check if target is a git repo
    if [[ ! -d "$target/.git" ]]; then
        echo -e "${RED}Error: Not a git repository: $target${NC}" >&2
        return 1
    fi

    local hooks_source="$HOME/code/jat/tools/scripts/hooks"
    local hooks_target="$target/.git/hooks"

    if [[ ! -d "$hooks_source" ]]; then
        echo -e "${RED}Error: JAT hooks not found at $hooks_source${NC}" >&2
        return 1
    fi

    echo ""
    echo -e "${BOLD}Installing JAT git hooks to: $target${NC}"
    echo ""

    # Install pre-commit hook
    if [[ -f "$hooks_target/pre-commit" ]]; then
        # Check if it's already our hook
        if grep -q "AGENT REGISTRATION CHECK" "$hooks_target/pre-commit" 2>/dev/null; then
            echo -e "  ${GREEN}âœ“${NC} pre-commit hook already installed (updating)"
        else
            echo -e "  ${YELLOW}âš ${NC} Existing pre-commit hook found, backing up to pre-commit.backup"
            cp "$hooks_target/pre-commit" "$hooks_target/pre-commit.backup"
        fi
    fi

    cp "$hooks_source/pre-commit" "$hooks_target/pre-commit"
    chmod +x "$hooks_target/pre-commit"
    echo -e "  ${GREEN}âœ“${NC} Installed pre-commit hook"

    echo ""
    echo -e "${GREEN}âœ“ JAT hooks installed!${NC}"
    echo ""
    echo "The pre-commit hook will:"
    echo "  â€¢ Block commits if no agent is registered (run /jat:start first)"
    echo "  â€¢ Auto-sync beads changes before commit"
    echo ""
    echo "To bypass: git commit --no-verify"
    echo ""
}

#------------------------------------------------------------------------------
# Find Session by Agent Name
#------------------------------------------------------------------------------

# Find session ID for an agent by name
# Searches: 1) .claude/sessions/agent-*.txt files, 2) signal files, 3) timeline files
# Returns: session_id or empty string
find_session_by_agent() {
    local target_agent="$1"
    local found_session=""
    local found_project=""
    local found_mtime=0

    # Method 1: Search .claude/sessions/agent-*.txt files in all projects
    # These files contain the agent name, filename contains session ID
    for project in $(list_projects 2>/dev/null); do
        local config path
        config=$(get_project_config "$project")
        path=$(echo "$config" | jq -r '.path' | sed "s|^~|$HOME|")

        # Check sessions subdirectory first
        for agent_file in "$path/.claude/sessions/agent-"*.txt; do
            [[ ! -f "$agent_file" ]] && continue
            local file_agent
            file_agent=$(cat "$agent_file" 2>/dev/null | tr -d '\n')
            if [[ "$file_agent" == "$target_agent" ]]; then
                # Extract session ID from filename: agent-{session_id}.txt
                local session_id
                session_id=$(basename "$agent_file" .txt | sed 's/^agent-//')
                # Get file modification time to find most recent
                local mtime
                mtime=$(stat -c %Y "$agent_file" 2>/dev/null || stat -f %m "$agent_file" 2>/dev/null || echo "0")
                if [[ "$mtime" -gt "$found_mtime" ]]; then
                    found_session="$session_id"
                    found_project="$project"
                    found_mtime="$mtime"
                fi
            fi
        done

        # Also check legacy location (.claude/agent-*.txt)
        for agent_file in "$path/.claude/agent-"*.txt; do
            [[ ! -f "$agent_file" ]] && continue
            [[ "$agent_file" == *"/sessions/"* ]] && continue  # Skip if somehow in sessions
            local file_agent
            file_agent=$(cat "$agent_file" 2>/dev/null | tr -d '\n')
            if [[ "$file_agent" == "$target_agent" ]]; then
                local session_id
                session_id=$(basename "$agent_file" .txt | sed 's/^agent-//')
                local mtime
                mtime=$(stat -c %Y "$agent_file" 2>/dev/null || stat -f %m "$agent_file" 2>/dev/null || echo "0")
                if [[ "$mtime" -gt "$found_mtime" ]]; then
                    found_session="$session_id"
                    found_project="$project"
                    found_mtime="$mtime"
                fi
            fi
        done
    done

    # Method 2: Search signal files in /tmp
    if [[ -z "$found_session" ]]; then
        for signal_file in /tmp/jat-signal-*.json; do
            [[ ! -f "$signal_file" ]] && continue
            [[ "$signal_file" == *"-tmux-"* ]] && continue

            local file_agent tmux_session file_session
            file_agent=$(jq -r '.data.agentName // empty' "$signal_file" 2>/dev/null)

            # Also check tmux_session field (format: jat-AgentName)
            if [[ -z "$file_agent" ]]; then
                tmux_session=$(jq -r '.tmux_session // empty' "$signal_file" 2>/dev/null)
                if [[ "$tmux_session" == "jat-$target_agent" ]]; then
                    file_agent="$target_agent"
                fi
            fi

            if [[ "$file_agent" == "$target_agent" ]]; then
                file_session=$(jq -r '.session_id // empty' "$signal_file" 2>/dev/null)
                if [[ -n "$file_session" ]]; then
                    found_session="$file_session"
                    found_project=$(jq -r '.data.project // empty' "$signal_file" 2>/dev/null)
                    break
                fi
            fi
        done
    fi

    # Method 3: Search timeline files
    if [[ -z "$found_session" ]]; then
        for timeline_file in /tmp/jat-timeline-*.jsonl; do
            [[ ! -f "$timeline_file" ]] && continue

            # Search for agent name in timeline
            local line
            line=$(grep "\"agentName\":\"$target_agent\"" "$timeline_file" 2>/dev/null | tail -1)
            if [[ -z "$line" ]]; then
                # Also try tmux_session format
                line=$(grep "\"tmux_session\":\"jat-$target_agent\"" "$timeline_file" 2>/dev/null | tail -1)
            fi

            if [[ -n "$line" ]]; then
                found_session=$(echo "$line" | jq -r '.session_id // empty')
                found_project=$(echo "$line" | jq -r '.data.project // empty')
                break
            fi
        done
    fi

    # Method 4: Search Claude's internal JSONL files (~/.claude/projects/)
    # These contain session history including /jat:start commands
    # The filename IS the session ID
    # Important: Check the FIRST command-args in each file to find who started it
    if [[ -z "$found_session" ]]; then
        for project_dir in ~/.claude/projects/-home-jw-code-*; do
            [[ ! -d "$project_dir" ]] && continue

            for jsonl_file in "$project_dir"/*.jsonl; do
                [[ ! -f "$jsonl_file" ]] && continue

                # Check if the FIRST /jat:start in this file is for our target agent
                local first_cmd
                first_cmd=$(grep -m1 'command-args' "$jsonl_file" 2>/dev/null)

                if echo "$first_cmd" | grep -q "command-args>${target_agent} \|command-args>${target_agent}<"; then
                    # This session was started by our target agent
                    found_session=$(basename "$jsonl_file" .jsonl)
                    # Extract project from directory name
                    local dir_name
                    dir_name=$(basename "$project_dir")
                    # dir_name is like "-home-jw-code-jat" -> extract "jat"
                    found_project=$(echo "$dir_name" | sed 's/.*-code-//' | sed 's/-.*$//')
                    break 2  # Break out of both loops
                fi
            done
        done
    fi

    # Output results
    if [[ -n "$found_session" ]]; then
        echo "$found_session"
        return 0
    fi
    return 1
}

# Command to find session by agent name
find_session_cmd() {
    local agent_name="$1"

    if [[ -z "$agent_name" ]] || [[ "$agent_name" == "--help" ]] || [[ "$agent_name" == "-h" ]]; then
        echo -e "${BOLD}Find session ID by agent name${NC}"
        echo ""
        echo -e "${DIM}Usage:${NC}"
        echo "  jat find-session <agent-name>"
        echo ""
        echo -e "${DIM}Examples:${NC}"
        echo "  jat find-session CrystalTundra"
        echo "  jat find-session WildWind"
        echo ""
        echo -e "${DIM}Then resume with:${NC}"
        echo "  jat resume \$(jat find-session CrystalTundra)"
        echo ""
        echo -e "${DIM}Or use the shortcut:${NC}"
        echo "  jat resume CrystalTundra"
        echo ""
        return 0
    fi

    local session_id
    session_id=$(find_session_by_agent "$agent_name")

    if [[ -n "$session_id" ]]; then
        echo "$session_id"
        return 0
    else
        echo -e "${RED}No session found for agent: $agent_name${NC}" >&2
        return 1
    fi
}

#------------------------------------------------------------------------------
# Resume Session
#------------------------------------------------------------------------------

resume_session() {
    local session_id="$1"
    local project="${2:-}"

    # Handle help and list flags first
    if [[ -z "$session_id" ]] || [[ "$session_id" == "--help" ]] || [[ "$session_id" == "-h" ]]; then
        echo -e "${BOLD}Resume a Claude Code session${NC}"
        echo ""
        echo -e "${DIM}Usage:${NC}"
        echo "  jat resume <agent-name>          # Resume by agent name"
        echo "  jat resume <session-id>          # Resume by session ID"
        echo "  jat resume --list [project]      # List recent sessions"
        echo ""
        echo -e "${DIM}Examples:${NC}"
        echo "  jat resume CrystalTundra                    # By agent name"
        echo "  jat resume 4a5001aa-04eb-47f6-a4da-75048baf # By session ID"
        echo "  jat resume 4a5001aa chimaro                 # Partial ID + project"
        echo "  jat resume --list                           # Show recent sessions"
        echo ""
        return 0
    fi

    # Handle --list flag
    if [[ "$session_id" == "--list" ]] || [[ "$session_id" == "-l" ]]; then
        list_sessions "$project"
        return $?
    fi

    # Check if input looks like an agent name (not a UUID or partial UUID)
    # Agent names are PascalCase words, UUIDs have dashes and hex chars
    local is_agent_name=false
    if [[ ! "$session_id" =~ ^[0-9a-f-]+$ ]]; then
        # Doesn't look like a UUID - try as agent name
        is_agent_name=true
    fi

    # If it looks like an agent name, try to find the session ID
    if [[ "$is_agent_name" == "true" ]]; then
        local looked_up_session
        looked_up_session=$(find_session_by_agent "$session_id")
        if [[ -n "$looked_up_session" ]]; then
            echo -e "${DIM}Found session for agent $session_id: ${looked_up_session:0:8}...${NC}"
            # Shift project to $2 position if agent name was in $1
            project="${project:-}"
            session_id="$looked_up_session"
        else
            echo -e "${RED}No session found for agent: $session_id${NC}"
            echo ""
            echo "Use 'jat resume --list' to see recent sessions"
            return 1
        fi
    fi

    # Find full session ID if partial provided
    local full_session_id=""
    local found_project=""
    local agent_name=""
    local task_id=""

    # Search through signal files in /tmp for matching session
    for signal_file in /tmp/jat-signal-*.json; do
        [[ ! -f "$signal_file" ]] && continue
        [[ "$signal_file" == *"-tmux-"* ]] && continue  # Skip tmux-keyed files

        local file_session_id file_project file_agent file_task file_tmux
        file_session_id=$(jq -r '.session_id // empty' "$signal_file" 2>/dev/null)

        if [[ -n "$file_session_id" ]] && [[ "$file_session_id" == "$session_id"* ]]; then
            full_session_id="$file_session_id"
            found_project=$(jq -r '.data.project // empty' "$signal_file" 2>/dev/null)
            agent_name=$(jq -r '.data.agentName // empty' "$signal_file" 2>/dev/null)
            task_id=$(jq -r '.task_id // empty' "$signal_file" 2>/dev/null)
            # If agent name not in data, extract from tmux_session (format: jat-AgentName)
            if [[ -z "$agent_name" ]]; then
                file_tmux=$(jq -r '.tmux_session // empty' "$signal_file" 2>/dev/null)
                if [[ "$file_tmux" == jat-* ]]; then
                    agent_name="${file_tmux#jat-}"
                fi
            fi
            break
        fi
    done

    # Also search timeline files for historical sessions or to fill in missing data
    # Even if we found the session in signal files, we may need more data from timeline
    if [[ -z "$full_session_id" ]] || [[ -z "$found_project" ]] || [[ -z "$agent_name" ]]; then
        local search_id="${full_session_id:-$session_id}"
        for timeline_file in /tmp/jat-timeline-*.jsonl; do
            [[ ! -f "$timeline_file" ]] && continue

            # Search for session_id that starts with the provided prefix
            # Prefer "starting" signals as they have the most complete data
            local line
            line=$(grep "\"session_id\":\"$search_id" "$timeline_file" 2>/dev/null | grep '"state":"starting"' | head -1)
            # Fall back to any matching line if no starting signal
            if [[ -z "$line" ]]; then
                line=$(grep "\"session_id\":\"$search_id" "$timeline_file" 2>/dev/null | head -1)
            fi
            if [[ -n "$line" ]]; then
                # Only update values we don't have yet
                [[ -z "$full_session_id" ]] && full_session_id=$(echo "$line" | jq -r '.session_id // empty')
                [[ -z "$found_project" ]] && found_project=$(echo "$line" | jq -r '.data.project // empty')
                [[ -z "$task_id" ]] && task_id=$(echo "$line" | jq -r '.task_id // empty')
                # For agent name, check data first, then tmux_session
                if [[ -z "$agent_name" ]]; then
                    agent_name=$(echo "$line" | jq -r '.data.agentName // empty')
                    if [[ -z "$agent_name" ]]; then
                        local file_tmux
                        file_tmux=$(echo "$line" | jq -r '.tmux_session // empty')
                        if [[ "$file_tmux" == jat-* ]]; then
                            agent_name="${file_tmux#jat-}"
                        fi
                    fi
                fi
                break
            fi
        done
    fi

    # If still not found, try using the session ID directly (might be complete)
    if [[ -z "$full_session_id" ]]; then
        # Check if it looks like a UUID
        if [[ "$session_id" =~ ^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$ ]]; then
            full_session_id="$session_id"
        else
            echo -e "${RED}Error: Session not found: $session_id${NC}"
            echo ""
            echo "Use 'jat resume --list' to see recent sessions"
            return 1
        fi
    fi

    # Fallback: If we have a session ID but no project, find it from JSONL files
    # The JSONL file location tells us the project
    if [[ -n "$full_session_id" ]] && [[ -z "$found_project" ]]; then
        for project_dir in ~/.claude/projects/-home-jw-code-*; do
            [[ ! -d "$project_dir" ]] && continue
            if [[ -f "$project_dir/${full_session_id}.jsonl" ]]; then
                local dir_name
                dir_name=$(basename "$project_dir")
                # dir_name is like "-home-jw-code-jat" -> extract "jat"
                found_project=$(echo "$dir_name" | sed 's/.*-code-//' | sed 's/-.*$//')
                break
            fi
        done
    fi

    # Determine project path
    local project_path=""
    if [[ -n "$project" ]]; then
        # User specified project
        local config
        config=$(get_project_config "$project")
        if [[ -z "$config" ]]; then
            echo -e "${RED}Unknown project: $project${NC}"
            return 1
        fi
        project_path=$(echo "$config" | jq -r '.path' | sed "s|^~|$HOME|")
    elif [[ -n "$found_project" ]]; then
        # Use project from signal
        local config
        config=$(get_project_config "$found_project")
        if [[ -n "$config" ]]; then
            project_path=$(echo "$config" | jq -r '.path' | sed "s|^~|$HOME|")
            project="$found_project"
        fi
    fi

    # Fall back to current directory if no project found
    if [[ -z "$project_path" ]]; then
        project_path="$(pwd)"
        project=$(basename "$project_path")
    fi

    echo ""
    echo -e "${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${BOLD}â•‘  ${CYAN}ðŸ”„ Resuming Session${NC}${BOLD}                                        â•‘${NC}"
    echo -e "${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    echo -e "  ${DIM}Session:${NC} ${full_session_id:0:8}..."
    [[ -n "$agent_name" ]] && echo -e "  ${DIM}Agent:${NC} $agent_name"
    [[ -n "$task_id" ]] && echo -e "  ${DIM}Task:${NC} $task_id"
    echo -e "  ${DIM}Project:${NC} $project_path"
    echo ""

    # Build environment
    local tools_path
    tools_path=$(jq -r '.defaults.tools_path // "~/.local/bin"' "$CONFIG_FILE" | sed "s|^~|$HOME|")
    local env_vars="PATH=$PATH:$tools_path:$project_path/.claude/tools"
    env_vars="$env_vars AGENT_MAIL_URL=http://localhost:8765"

    # Get claude flags from config
    local claude_flags
    claude_flags=$(jq -r '.defaults.claude_flags // "--dangerously-skip-permissions"' "$CONFIG_FILE")

    # JAT bootstrap prompt
    local jat_bootstrap='You are a JAT agent. Run /jat:start to begin work.'
    claude_flags="$claude_flags --append-system-prompt '$jat_bootstrap'"

    # Create session name - use agent name if available, fallback to resume-{short-id}
    local session_name
    if [[ -n "$agent_name" ]]; then
        session_name="jat-${agent_name}"
    else
        session_name="jat-resume-${full_session_id:0:8}"
    fi

    # Window title
    local window_title="${project^^}: Claude (resumed)"
    [[ -n "$agent_name" ]] && window_title="${project^^}: $agent_name (resumed)"

    echo -e "${DIM}  â†’ Launching Claude Code with session resume...${NC}"

    # Write resume marker file so IDE can show "RESUMED" badge
    local resume_marker="/tmp/jat-resumed-${session_name}.json"
    cat > "$resume_marker" <<EOF
{
    "resumed": true,
    "originalSessionId": "$full_session_id",
    "agentName": "${agent_name:-unknown}",
    "project": "$found_project",
    "resumedAt": "$(date -Iseconds)"
}
EOF

    # Launch terminal with tmux session containing resumed Claude
    $TERMINAL -T "$window_title" -e bash -c "
        cd '$project_path'
        tmux new-session -d -s '$session_name' -x 120 -y 40 -c '$project_path'
        tmux set-option -t '$session_name' history-limit 50000
        sleep 0.3
        tmux send-keys -t '$session_name' '$env_vars claude $claude_flags -r \"$full_session_id\"' Enter
        tmux attach-session -t '$session_name'
    " &

    echo ""
    echo -e "${GREEN}âœ“ Session resume launched${NC}"
    echo ""
    echo -e "${DIM}Claude will resume from the previous conversation state.${NC}"
}

list_sessions() {
    local filter_project="$1"

    echo ""
    echo -e "${BOLD}Recent Sessions:${NC}"
    echo ""

    # Collect sessions from timeline files
    local sessions=""

    for timeline_file in /tmp/jat-timeline-*.jsonl; do
        [[ ! -f "$timeline_file" ]] && continue

        # Get the most recent starting signal from each timeline
        # Note: signals have type="state" and state="starting"
        local starting_line
        starting_line=$(grep '"state":"starting"' "$timeline_file" 2>/dev/null | tail -1)

        if [[ -n "$starting_line" ]]; then
            local session_id agent_name task_id project timestamp tmux_session
            session_id=$(echo "$starting_line" | jq -r '.session_id // empty')
            agent_name=$(echo "$starting_line" | jq -r '.data.agentName // empty')
            task_id=$(echo "$starting_line" | jq -r '.task_id // empty')
            project=$(echo "$starting_line" | jq -r '.data.project // empty')
            timestamp=$(echo "$starting_line" | jq -r '.timestamp // empty')
            tmux_session=$(echo "$starting_line" | jq -r '.tmux_session // empty')

            # Filter by project if specified
            if [[ -n "$filter_project" ]] && [[ "$project" != "$filter_project" ]]; then
                continue
            fi

            # Check if session is still active (tmux session exists)
            local status="${DIM}ended${NC}"
            if tmux has-session -t "$tmux_session" 2>/dev/null; then
                status="${GREEN}active${NC}"
            fi

            # Format timestamp
            local formatted_time
            if [[ -n "$timestamp" ]]; then
                formatted_time=$(date -d "$timestamp" "+%Y-%m-%d %H:%M" 2>/dev/null || echo "$timestamp")
            else
                formatted_time="-"
            fi

            sessions+="$timestamp|$session_id|$agent_name|$task_id|$project|$status|$formatted_time"$'\n'
        fi
    done

    if [[ -z "$sessions" ]]; then
        echo -e "  ${DIM}No sessions found${NC}"
        echo ""
        return 0
    fi

    # Print header
    printf "  ${DIM}%-10s %-12s %-12s %-15s %-8s %-16s${NC}\n" \
        "SESSION" "AGENT" "TASK" "PROJECT" "STATUS" "TIME"
    printf "  ${DIM}%-10s %-12s %-12s %-15s %-8s %-16s${NC}\n" \
        "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

    # Sort by timestamp descending and print
    echo "$sessions" | sort -t'|' -k1 -rn | head -20 | while IFS='|' read -r ts session_id agent_name task_id project status formatted_time; do
        [[ -z "$session_id" ]] && continue

        # Truncate fields for display
        local short_id="${session_id:0:8}"
        local short_agent="${agent_name:0:11}"
        local short_task="${task_id:0:11}"
        local short_project="${project:0:14}"

        printf "  %-10s %-12s %-12s %-15s %-8b %-16s\n" \
            "$short_id" "$short_agent" "$short_task" "$short_project" "$status" "$formatted_time"
    done

    echo ""
    echo -e "${DIM}Resume with: jat resume <session-id>${NC}"
    echo ""
}

#------------------------------------------------------------------------------
# Demo Environment
#------------------------------------------------------------------------------

demo_cmd() {
    local subcmd="${1:-}"

    case "$subcmd" in
        setup)
            # Always do a clean setup (remove old, create new)
            echo -e "${BLUE}Setting up fresh demo environment...${NC}"
            echo ""

            # First clean any existing demo projects
            if command -v jat-demo &>/dev/null; then
                # Clean silently (no confirmation prompt)
                echo "y" | jat-demo clean >/dev/null 2>&1
                # Now set up fresh
                jat-demo setup
            else
                echo -e "${RED}jat-demo tool not found${NC}"
                return 1
            fi
            ;;
        on|show)
            # Show only demo projects
            if command -v jat-demo &>/dev/null; then
                jat-demo on
            else
                echo -e "${RED}jat-demo tool not found${NC}"
                return 1
            fi
            ;;
        off|hide)
            # Hide demo projects, show regular projects
            if command -v jat-demo &>/dev/null; then
                jat-demo off
            else
                echo -e "${RED}jat-demo tool not found${NC}"
                return 1
            fi
            ;;
        --help|-h|help)
            echo ""
            echo -e "${BOLD}JAT Demo Environment${NC}"
            echo ""
            echo "Demo projects for presentations and testing."
            echo ""
            echo -e "${DIM}Usage:${NC}"
            echo "  jat demo           Launch IDE with demo projects"
            echo "  jat demo setup     Fresh setup (removes old, creates new)"
            echo "  jat demo on        Show only demo projects"
            echo "  jat demo off       Hide demo projects"
            echo ""
            echo -e "${DIM}Demo projects:${NC}"
            echo "  jat-demo-blog      - Blog platform (red/pink)"
            echo "  jat-demo-shop      - E-commerce store (green)"
            echo "  jat-demo-dashboard - Analytics dashboard (blue)"
            echo ""
            ;;
        "")
            # Default: setup if needed, then launch IDE
            echo ""
            echo -e "${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
            echo -e "${BOLD}â•‘              ${CYAN}ðŸŽ¬ JAT Demo Mode${NC}${BOLD}                                â•‘${NC}"
            echo -e "${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
            echo ""

            # Check if demo projects exist
            local demo_exists=false
            if jq -e '.projects."jat-demo-blog"' "$CONFIG_FILE" >/dev/null 2>&1; then
                demo_exists=true
            fi

            if [[ "$demo_exists" == "false" ]]; then
                echo -e "${YELLOW}Demo projects not found. Setting up...${NC}"
                echo ""
                jat-demo setup
                echo ""
            fi

            # Make demo projects visible
            echo -e "${BLUE}Showing demo projects...${NC}"
            jat-demo on
            echo ""

            echo "Demo projects:"
            echo -e "  ${CYAN}jat-demo-blog${NC}      - Blog platform"
            echo -e "  ${CYAN}jat-demo-shop${NC}      - E-commerce store"
            echo -e "  ${CYAN}jat-demo-dashboard${NC} - Analytics dashboard"
            echo ""
            echo -e "${DIM}Launching IDE...${NC}"
            echo ""

            # Launch IDE
            launch_ide "DEMO"
            ;;
        *)
            echo -e "${RED}Unknown demo command: $subcmd${NC}"
            echo "Run 'jat demo --help' for usage"
            return 1
            ;;
    esac
}

#------------------------------------------------------------------------------
# Main
#------------------------------------------------------------------------------

main() {
    ensure_config

    if [[ $# -eq 0 ]]; then
        # No arguments - launch IDE
        echo ""
        echo -e "${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
        echo -e "${BOLD}â•‘              ${CYAN}ðŸš€ JAT IDE${NC}${BOLD}                                       â•‘${NC}"
        echo -e "${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
        echo ""

        # Check for updates only on IDE launch (interactive prompt)
        interactive_update_check

        launch_ide "JAT"
        exit 0
    fi

    local cmd="$1"
    shift

    case "$cmd" in
        help|--help|-h)
            show_help
            ;;
        list|ls)
            list_all
            ;;
        init)
            init_projects
            ;;
        config)
            show_config "$@"
            ;;
        edit)
            edit_config
            ;;
        cleanup)
            cleanup_agents "$@"
            ;;
        add)
            add_project "$@"
            ;;
        remove|rm)
            remove_project "$@"
            ;;
        resume|-r)
            resume_session "$@"
            ;;
        find-session|-fs)
            find_session_cmd "$@"
            ;;
        demo)
            demo_cmd "$@"
            ;;
        update)
            update_cmd "$@"
            ;;
        # Hidden/advanced commands (kept for backwards compatibility)
        colors)
            apply_all_colors
            ;;
        hooks)
            install_hooks "$@"
            ;;
        *)
            # Check if it's a known project (backwards compatibility)
            local config
            config=$(get_project_config "$cmd")
            if [[ -n "$config" ]]; then
                echo -e "${YELLOW}Note: Direct project launching is deprecated.${NC}"
                echo -e "${YELLOW}Please use the IDE to manage agents.${NC}"
                echo ""
                launch_project "$cmd" "$@"
            else
                echo -e "${RED}Unknown command: $cmd${NC}"
                echo "Run 'jat --help' for usage"
                exit 1
            fi
            ;;
    esac
}

main "$@"
