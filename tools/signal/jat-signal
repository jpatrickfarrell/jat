#!/usr/bin/env bash
#
# jat-signal - Emit structured signals for dashboard consumption
#
# Usage (State Signals - require JSON payload):
#   jat-signal working '{"taskId":"jat-abc","taskTitle":"..."}'
#   jat-signal review '{"taskId":"jat-abc","summary":["..."]}'
#   jat-signal needs_input '{"taskId":"jat-abc","question":"...","questionType":"choice"}'
#   jat-signal idle '{"readyForWork":true}'
#   jat-signal completing '{"taskId":"jat-abc","currentStep":"committing"}'
#   jat-signal starting '{"agentName":"...","project":"..."}'
#   jat-signal compacting '{"reason":"...","contextSizeBefore":180000}'
#   jat-signal question '{"question":"...","questionType":"choice","options":[...]}'
#
# Usage (Completion Signal - bundles everything):
#   jat-signal complete '{"taskId":"...","agentName":"...","summary":[...],"quality":{...},"suggestedTasks":[...]}'
#
# Options:
#   --no-validate    Skip JSON schema validation
#   --strict         Fail on validation errors (default: warn)
#
# All signals emit: [JAT-SIGNAL:<TYPE>] <json-payload>
# The PostToolUse hook captures this and writes to temp file.
# Dashboard reads /tmp/jat-signal-{session}.json via SSE.

set -euo pipefail

# Script directory for finding validation tool
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")")" && pwd)"

# Try to find validation script in multiple locations
find_validator() {
    local locations=(
        "/home/jw/code/jat/signal/jat-signal-validate"
        "${SCRIPT_DIR}/jat-signal-validate"
    )
    for loc in "${locations[@]}"; do
        if [[ -x "$loc" ]]; then
            echo "$loc"
            return 0
        fi
    done
    return 1
}

show_usage() {
    echo "Usage: jat-signal <signal> <json-payload> [--no-validate] [--strict]"
    echo ""
    echo "State Signals (require JSON payload):"
    echo "  working '{...}'       - Working on task"
    echo "  review '{...}'        - Ready for human review"
    echo "  needs_input '{...}'   - Waiting for user input"
    echo "  idle '{...}'          - Session idle"
    echo "  completing '{...}'    - Running completion steps"
    echo "  starting '{...}'      - Session initializing"
    echo "  compacting '{...}'    - Summarizing context"
    echo "  question '{...}'      - Structured question for dashboard"
    echo ""
    echo "Completion Signal (USE jat-complete-bundle TO GENERATE):"
    echo "  complete '{...}'      - Full completion bundle (see below)"
    echo ""
    echo "Options:"
    echo "  --no-validate         Skip schema validation"
    echo "  --strict              Fail on validation errors (default: warn)"
    echo ""
    echo "Examples:"
    echo "  jat-signal working '{\"taskId\":\"jat-abc\",\"taskTitle\":\"Add auth\"}'"
    echo "  jat-signal review '{\"taskId\":\"jat-abc\",\"summary\":[\"Added login\"]}'"
    echo "  jat-signal needs_input '{\"taskId\":\"jat-abc\",\"question\":\"Which lib?\",\"questionType\":\"choice\"}'"
    echo "  jat-signal idle '{\"readyForWork\":true}'"
    echo ""
    echo "COMPLETE SIGNAL - DO NOT MANUALLY CONSTRUCT:"
    echo "  Use jat-complete-bundle to generate the JSON payload:"
    echo "    BUNDLE=\$(jat-complete-bundle --task jat-abc --agent AgentName)"
    echo "    jat-signal complete \"\$BUNDLE\""
    echo ""
    echo "Required Fields by Signal Type:"
    echo "  working:     taskId, taskTitle"
    echo "  review:      taskId"
    echo "  needs_input: taskId, question, questionType"
    echo "  idle:        readyForWork"
    echo "  completing:  taskId, currentStep"
    echo "  starting:    agentName"
    echo "  compacting:  reason, contextSizeBefore"
    echo "  question:    question, questionType"
    echo "  complete:    (use jat-complete-bundle, do not construct manually)"
}

# Parse options
VALIDATE=true
STRICT=false
POSITIONAL_ARGS=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        --no-validate)
            VALIDATE=false
            shift
            ;;
        --strict)
            STRICT=true
            shift
            ;;
        -h|--help|help)
            show_usage
            exit 0
            ;;
        *)
            POSITIONAL_ARGS+=("$1")
            shift
            ;;
    esac
done

set -- "${POSITIONAL_ARGS[@]:-}"

SIGNAL_TYPE="${1:-}"
SIGNAL_DATA="${2:-}"

# Validate signal payload
validate_payload() {
    local signal_type="$1"
    local payload="$2"

    if [[ "$VALIDATE" != "true" ]]; then
        return 0
    fi

    local validator
    if ! validator=$(find_validator); then
        echo "Warning: jat-signal-validate not found, skipping validation" >&2
        return 0
    fi

    local validation_output
    local validation_exit=0

    validation_output=$("$validator" "$signal_type" "$payload" 2>&1) || validation_exit=$?

    if [[ $validation_exit -ne 0 ]]; then
        # Always fail on missing required fields (even in non-strict mode)
        # This prevents incomplete signals from being emitted
        if echo "$validation_output" | grep -q "missing required field"; then
            echo "Error: $validation_output" >&2
            echo "Hint: Include all required fields in your signal payload" >&2
            exit 1
        fi

        if [[ "$STRICT" == "true" ]]; then
            echo "Error: Validation failed: $validation_output" >&2
            exit 1
        else
            echo "Warning: $validation_output" >&2
        fi
    fi

    return 0
}

# Require JSON payload for state signals
require_json() {
    local signal_type="$1"
    local data="$2"

    if [[ -z "$data" ]]; then
        echo "Error: $signal_type requires JSON payload"
        echo "Example: jat-signal $signal_type '{\"taskId\":\"...\"}'"
        exit 1
    fi

    if ! echo "$data" | jq . >/dev/null 2>&1; then
        echo "Error: Invalid JSON for $signal_type signal"
        exit 1
    fi
}

if [[ -z "$SIGNAL_TYPE" ]]; then
    show_usage
    exit 1
fi

case "$SIGNAL_TYPE" in
    working)
        require_json "working" "$SIGNAL_DATA"
        # Compact JSON to single line for hook parsing
        SIGNAL_DATA=$(echo "$SIGNAL_DATA" | jq -c .)
        validate_payload "working" "$SIGNAL_DATA"
        TASK_ID=$(echo "$SIGNAL_DATA" | jq -r '.taskId // ""')
        TASK_TITLE=$(echo "$SIGNAL_DATA" | jq -r '.taskTitle // ""')
        echo "Signal: working (task: ${TASK_ID} - ${TASK_TITLE})"
        echo "[JAT-SIGNAL:working] $SIGNAL_DATA"
        ;;

    review|needs_review)
        require_json "review" "$SIGNAL_DATA"
        # Compact JSON to single line for hook parsing
        SIGNAL_DATA=$(echo "$SIGNAL_DATA" | jq -c .)
        validate_payload "review" "$SIGNAL_DATA"
        TASK_ID=$(echo "$SIGNAL_DATA" | jq -r '.taskId // ""')
        SUMMARY_COUNT=$(echo "$SIGNAL_DATA" | jq '.summary // [] | length')
        echo "Signal: review (task: ${TASK_ID}, ${SUMMARY_COUNT} items)"
        echo "[JAT-SIGNAL:review] $SIGNAL_DATA"
        ;;

    needs_input|input)
        require_json "needs_input" "$SIGNAL_DATA"
        # Compact JSON to single line for hook parsing
        SIGNAL_DATA=$(echo "$SIGNAL_DATA" | jq -c .)
        validate_payload "needs_input" "$SIGNAL_DATA"
        TASK_ID=$(echo "$SIGNAL_DATA" | jq -r '.taskId // ""')
        QUESTION_TYPE=$(echo "$SIGNAL_DATA" | jq -r '.questionType // "text"')
        echo "Signal: needs_input (task: ${TASK_ID}, type: ${QUESTION_TYPE})"
        echo "[JAT-SIGNAL:needs_input] $SIGNAL_DATA"
        ;;

    idle)
        require_json "idle" "$SIGNAL_DATA"
        # Compact JSON to single line for hook parsing
        SIGNAL_DATA=$(echo "$SIGNAL_DATA" | jq -c .)
        validate_payload "idle" "$SIGNAL_DATA"
        READY=$(echo "$SIGNAL_DATA" | jq -r '.readyForWork // true')
        TASKS_COMPLETED=$(echo "$SIGNAL_DATA" | jq -r '.sessionSummary.tasksCompleted // [] | length')
        SUGGESTED=$(echo "$SIGNAL_DATA" | jq -r '.suggestedNextTask.taskId // ""')
        BLOCKED=$(echo "$SIGNAL_DATA" | jq -r '.blockedReason // ""')
        if [[ -n "$BLOCKED" ]]; then
            echo "Signal: idle (ready: ${READY}, blocked: ${BLOCKED})"
        elif [[ "$TASKS_COMPLETED" -gt 0 ]] && [[ -n "$SUGGESTED" ]]; then
            echo "Signal: idle (ready: ${READY}, completed: ${TASKS_COMPLETED}, next: ${SUGGESTED})"
        elif [[ "$TASKS_COMPLETED" -gt 0 ]]; then
            echo "Signal: idle (ready: ${READY}, completed: ${TASKS_COMPLETED} tasks)"
        elif [[ -n "$SUGGESTED" ]]; then
            echo "Signal: idle (ready: ${READY}, next: ${SUGGESTED})"
        else
            echo "Signal: idle (ready: ${READY})"
        fi
        echo "[JAT-SIGNAL:idle] $SIGNAL_DATA"
        ;;

    completing)
        require_json "completing" "$SIGNAL_DATA"
        # Compact JSON to single line for hook parsing
        SIGNAL_DATA=$(echo "$SIGNAL_DATA" | jq -c .)
        validate_payload "completing" "$SIGNAL_DATA"
        TASK_ID=$(echo "$SIGNAL_DATA" | jq -r '.taskId // ""')
        STEP=$(echo "$SIGNAL_DATA" | jq -r '.currentStep // ""')
        echo "Signal: completing (task: ${TASK_ID}, step: ${STEP})"
        echo "[JAT-SIGNAL:completing] $SIGNAL_DATA"
        ;;

    starting)
        require_json "starting" "$SIGNAL_DATA"
        # Compact JSON to single line for hook parsing
        SIGNAL_DATA=$(echo "$SIGNAL_DATA" | jq -c .)
        validate_payload "starting" "$SIGNAL_DATA"
        AGENT_NAME=$(echo "$SIGNAL_DATA" | jq -r '.agentName // ""')
        PROJECT=$(echo "$SIGNAL_DATA" | jq -r '.project // ""')
        TASK_ID=$(echo "$SIGNAL_DATA" | jq -r '.taskId // ""')
        SESSION_ID=$(echo "$SIGNAL_DATA" | jq -r '.sessionId // ""')
        # Build output message with available info
        OUTPUT="Signal: starting (agent: ${AGENT_NAME}"
        [[ -n "$PROJECT" ]] && OUTPUT="$OUTPUT, project: ${PROJECT}"
        [[ -n "$TASK_ID" ]] && OUTPUT="$OUTPUT, task: ${TASK_ID}"
        [[ -n "$SESSION_ID" ]] && OUTPUT="$OUTPUT, session: ${SESSION_ID:0:8}...)"
        [[ -z "$SESSION_ID" ]] && OUTPUT="$OUTPUT)"
        echo "$OUTPUT"
        echo "[JAT-SIGNAL:starting] $SIGNAL_DATA"
        ;;

    compacting)
        require_json "compacting" "$SIGNAL_DATA"
        # Compact JSON to single line for hook parsing
        SIGNAL_DATA=$(echo "$SIGNAL_DATA" | jq -c .)
        validate_payload "compacting" "$SIGNAL_DATA"
        REASON=$(echo "$SIGNAL_DATA" | jq -r '.reason // ""')
        CONTEXT_BEFORE=$(echo "$SIGNAL_DATA" | jq -r '.contextSizeBefore // 0')
        echo "Signal: compacting (reason: ${REASON}, context: ${CONTEXT_BEFORE})"
        echo "[JAT-SIGNAL:compacting] $SIGNAL_DATA"
        ;;

    question)
        require_json "question" "$SIGNAL_DATA"
        # Compact JSON to single line for hook parsing
        SIGNAL_DATA=$(echo "$SIGNAL_DATA" | jq -c .)
        validate_payload "question" "$SIGNAL_DATA"
        QUESTION_TEXT=$(echo "$SIGNAL_DATA" | jq -r '.question // ""')
        QUESTION_TYPE=$(echo "$SIGNAL_DATA" | jq -r '.questionType // "choice"')
        OPTIONS_COUNT=$(echo "$SIGNAL_DATA" | jq '.options // [] | length')
        # Truncate question text for display
        QUESTION_SHORT="${QUESTION_TEXT:0:50}"
        [[ ${#QUESTION_TEXT} -gt 50 ]] && QUESTION_SHORT="${QUESTION_SHORT}..."
        echo "Signal: question (type: ${QUESTION_TYPE}, options: ${OPTIONS_COUNT})"
        echo "[JAT-SIGNAL:question] $SIGNAL_DATA"
        ;;

    complete)
        if [[ -n "$SIGNAL_DATA" ]]; then
            if ! echo "$SIGNAL_DATA" | jq . >/dev/null 2>&1; then
                echo "Error: Invalid JSON for complete signal"
                exit 1
            fi
            # Compact JSON to single line for hook parsing
            SIGNAL_DATA=$(echo "$SIGNAL_DATA" | jq -c .)
            validate_payload "complete" "$SIGNAL_DATA"
            TASK_COUNT=$(echo "$SIGNAL_DATA" | jq '.suggestedTasks // [] | length')
            ACTION_COUNT=$(echo "$SIGNAL_DATA" | jq '.humanActions // [] | length')
            echo "Signal: complete (${TASK_COUNT} tasks, ${ACTION_COUNT} actions)"
        else
            SIGNAL_DATA="{}"
            echo "Signal: complete"
        fi
        echo "[JAT-SIGNAL:complete] $SIGNAL_DATA"
        ;;

    -h|--help|help)
        show_usage
        exit 0
        ;;

    *)
        echo "Error: Unknown signal type '$SIGNAL_TYPE'"
        show_usage
        exit 1
        ;;
esac

exit 0
