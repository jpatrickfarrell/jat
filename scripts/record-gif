#!/bin/bash
# record-gif - Record screen region to optimized GIF (Wayland)
#
# Usage:
#   record-gif [output.gif]           # Interactive region select
#   record-gif --help                 # Show help
#
# Requirements:
#   - gpu-screen-recorder (GPU-accelerated screen recorder)
#   - slurp (region selector)
#   - ffmpeg (video processing)
#
# These are typically pre-installed on Omarchy/Jomarchy

set -e

# Defaults
OUTPUT="${1:-demo.gif}"
FPS=10
RECORD_FPS=30
WIDTH=800
TMP_VIDEO="/tmp/record-gif-$$.mp4"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'
NC='\033[0m'

show_help() {
    cat << 'EOF'
record-gif - Record screen region to optimized GIF (Wayland)

USAGE:
    record-gif [OPTIONS] [output.gif]

OPTIONS:
    -h, --help      Show this help
    -f, --fps N     GIF frames per second (default: 10)
    -w, --width N   Output width in pixels (default: 800)
    --mp4           Output mp4 instead of GIF (better for GitHub)
    --no-optimize   Skip optimization pass

EXAMPLES:
    record-gif                      # Record to demo.gif
    record-gif dashboard.gif        # Record to dashboard.gif
    record-gif -f 15 -w 1200 hq.gif # Higher quality
    record-gif --mp4 demo.mp4       # Output mp4 for GitHub

WORKFLOW:
    1. Run this script
    2. Select the region to record (click and drag)
    3. Recording starts - do your demo
    4. Press Ctrl+C to stop
    5. GIF is generated automatically

FOR README GIFS:
    # Start dashboard first
    jat-dashboard

    # In another terminal, start recording
    record-gif assets/dashboard-demo.gif

    # Select the browser window region
    # Do your demo (spawn agents, click questions, etc)
    # Press Ctrl+C when done

NOTE:
    GitHub READMEs support embedded mp4 which looks better than GIF.
    Use --mp4 flag for GitHub-hosted videos.
EOF
}

check_deps() {
    local missing=()

    if ! command -v gpu-screen-recorder &>/dev/null; then
        missing+=("gpu-screen-recorder")
    fi

    if ! command -v slurp &>/dev/null; then
        missing+=("slurp")
    fi

    if ! command -v ffmpeg &>/dev/null; then
        missing+=("ffmpeg")
    fi

    if [[ ${#missing[@]} -gt 0 ]]; then
        echo -e "${RED}Missing dependencies:${NC} ${missing[*]}"
        echo ""
        echo "Install on Arch Linux:"
        echo "  sudo pacman -S ${missing[*]}"
        echo ""
        echo "Note: gpu-screen-recorder may be in AUR"
        echo "  yay -S gpu-screen-recorder"
        exit 1
    fi

    # Check if running on Wayland
    if [[ "$XDG_SESSION_TYPE" != "wayland" ]]; then
        echo -e "${YELLOW}Warning:${NC} This script is optimized for Wayland."
        echo "Detected session type: $XDG_SESSION_TYPE"
        echo ""
        echo "gpu-screen-recorder works on X11 too, continuing..."
    fi
}

parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -f|--fps)
                FPS="$2"
                shift 2
                ;;
            -w|--width)
                WIDTH="$2"
                shift 2
                ;;
            --mp4)
                OUTPUT_MP4=1
                shift
                ;;
            --no-optimize)
                NO_OPTIMIZE=1
                shift
                ;;
            -*)
                echo -e "${RED}Unknown option:${NC} $1"
                echo "Use --help for usage"
                exit 1
                ;;
            *)
                OUTPUT="$1"
                shift
                ;;
        esac
    done

    # Handle extension
    if [[ -n "$OUTPUT_MP4" ]]; then
        if [[ "$OUTPUT" != *.mp4 ]]; then
            OUTPUT="${OUTPUT%.gif}.mp4"
        fi
    else
        if [[ "$OUTPUT" != *.gif ]]; then
            OUTPUT="${OUTPUT}.gif"
        fi
    fi
}

cleanup() {
    rm -f "$TMP_VIDEO" "${TMP_VIDEO%.mp4}-palette.png"
}

record() {
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${GREEN}GIF Recorder${NC} (gpu-screen-recorder)"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    echo -e "Output: ${YELLOW}$OUTPUT${NC}"
    if [[ -n "$OUTPUT_MP4" ]]; then
        echo -e "Format: mp4 (direct output)"
    else
        echo -e "Settings: ${FPS}fps GIF, ${WIDTH}px width"
    fi
    echo ""
    echo -e "${YELLOW}Step 1:${NC} Click and drag to select the region to record"
    echo ""

    # Get region using slurp
    GEOMETRY=$(slurp 2>/dev/null)
    if [[ -z "$GEOMETRY" ]]; then
        echo -e "${RED}No region selected. Exiting.${NC}"
        exit 1
    fi

    echo -e "${GREEN}Region selected:${NC} $GEOMETRY"
    echo ""
    echo -e "${YELLOW}Step 2:${NC} Recording... Press ${RED}Ctrl+C${NC} to stop"
    echo ""

    # Set up cleanup trap (only for GIF mode)
    if [[ -z "$OUTPUT_MP4" ]]; then
        trap cleanup EXIT
    fi

    # Determine output file
    if [[ -n "$OUTPUT_MP4" ]]; then
        RECORD_OUTPUT="$OUTPUT"
    else
        RECORD_OUTPUT="$TMP_VIDEO"
    fi

    # Record using gpu-screen-recorder
    # -w region: use region capture mode
    # -region: the geometry from slurp (WxH+X+Y format)
    # -f: framerate
    # -o: output file
    gpu-screen-recorder -w region -region "$GEOMETRY" -f "$RECORD_FPS" -o "$RECORD_OUTPUT" || true

    echo ""

    # If mp4 mode, we're done
    if [[ -n "$OUTPUT_MP4" ]]; then
        if [[ -f "$OUTPUT" ]]; then
            SIZE=$(du -h "$OUTPUT" | cut -f1)
            echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
            echo -e "${GREEN}✓ MP4 created successfully!${NC}"
            echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
            echo ""
            echo -e "  File: ${YELLOW}$OUTPUT${NC}"
            echo -e "  Size: ${SIZE}"
            echo ""
            echo "Upload to GitHub and embed in README:"
            echo "  https://github.com/user-attachments/assets/your-video.mp4"
        else
            echo -e "${RED}Recording failed - no video file created${NC}"
            exit 1
        fi
        return
    fi

    echo -e "${YELLOW}Step 3:${NC} Converting to GIF..."
    echo ""

    if [[ ! -f "$TMP_VIDEO" ]]; then
        echo -e "${RED}Recording failed - no video file created${NC}"
        exit 1
    fi

    # Get video duration
    DURATION=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$TMP_VIDEO" 2>/dev/null || echo "unknown")
    echo -e "Video duration: ${DURATION}s"

    # Generate palette for better colors
    echo "Generating color palette..."
    ffmpeg -y -i "$TMP_VIDEO" \
        -vf "fps=$FPS,scale=$WIDTH:-1:flags=lanczos,palettegen=stats_mode=diff" \
        "${TMP_VIDEO%.mp4}-palette.png" \
        -hide_banner -loglevel error

    # Convert to GIF using palette
    echo "Creating GIF..."
    ffmpeg -y -i "$TMP_VIDEO" -i "${TMP_VIDEO%.mp4}-palette.png" \
        -lavfi "fps=$FPS,scale=$WIDTH:-1:flags=lanczos[x];[x][1:v]paletteuse=dither=bayer:bayer_scale=5:diff_mode=rectangle" \
        "$OUTPUT" \
        -hide_banner -loglevel error

    # Get file size
    SIZE=$(du -h "$OUTPUT" | cut -f1)

    echo ""
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${GREEN}✓ GIF created successfully!${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    echo -e "  File: ${YELLOW}$OUTPUT${NC}"
    echo -e "  Size: ${SIZE}"
    echo ""

    # Suggest optimization if large
    SIZE_KB=$(du -k "$OUTPUT" | cut -f1)
    if [[ $SIZE_KB -gt 5000 ]]; then
        echo -e "${YELLOW}Tip:${NC} GIF is over 5MB. Consider:"
        echo "  - Shorter recording"
        echo "  - Lower FPS: record-gif -f 8 $OUTPUT"
        echo "  - Smaller width: record-gif -w 600 $OUTPUT"
        echo "  - Use mp4 instead: record-gif --mp4 demo.mp4"
        echo "  - Use gifsicle: gifsicle -O3 --lossy=80 $OUTPUT -o optimized.gif"
        echo ""
    fi

    echo "Add to README:"
    echo "  ![Dashboard Demo](./$OUTPUT)"
}

main() {
    parse_args "$@"
    check_deps
    record
}

main "$@"
