#!/bin/bash

# JAT CLI - Jomarchy Agent Tools
# Launch complete dev environments with Hyprland colored borders

set -e

# Config location
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/jat"
CONFIG_FILE="$CONFIG_DIR/projects.json"

# Colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# Default terminal (can be overridden in config)
TERMINAL="${JAT_TERMINAL:-alacritty}"

#------------------------------------------------------------------------------
# Config Management
#------------------------------------------------------------------------------

ensure_config() {
    if [[ ! -d "$CONFIG_DIR" ]]; then
        mkdir -p "$CONFIG_DIR"
    fi

    if [[ ! -f "$CONFIG_FILE" ]]; then
        # Create default config
        cat > "$CONFIG_FILE" << 'EOF'
{
  "projects": {},
  "defaults": {
    "terminal": "alacritty",
    "editor": "code",
    "tools_path": "~/.local/bin",
    "claude_flags": "--dangerously-skip-permissions"
  }
}
EOF
        echo -e "${GREEN}Created config: $CONFIG_FILE${NC}"
    fi
}

get_project_config() {
    local project="$1"
    jq -r ".projects[\"$project\"] // empty" "$CONFIG_FILE"
}

list_projects() {
    jq -r '.projects | keys[]' "$CONFIG_FILE" 2>/dev/null
}

#------------------------------------------------------------------------------
# Hyprland Window Coloring
#------------------------------------------------------------------------------

apply_border_color() {
    local title_prefix="$1"
    local active_color="$2"
    local inactive_color="$3"

    if ! command -v hyprctl &>/dev/null; then
        return 0  # Skip if not on Hyprland
    fi

    hyprctl clients -j 2>/dev/null | jq -r ".[] | select(.title | startswith(\"$title_prefix\")) | .address" | while read -r addr; do
        hyprctl dispatch setprop "address:$addr" activebordercolor "$active_color" &>/dev/null || true
        hyprctl dispatch setprop "address:$addr" inactivebordercolor "$inactive_color" &>/dev/null || true
    done
}

apply_all_colors() {
    local projects
    projects=$(list_projects)

    for project in $projects; do
        local config
        config=$(get_project_config "$project")
        local name active_color inactive_color
        name=$(echo "$config" | jq -r '.name')
        active_color=$(echo "$config" | jq -r '.active_color // empty')
        inactive_color=$(echo "$config" | jq -r '.inactive_color // empty')

        if [[ -n "$active_color" ]]; then
            apply_border_color "$name:" "$active_color" "$inactive_color"
        fi
    done
    echo -e "${GREEN}Applied colors to all project windows${NC}"
}

#------------------------------------------------------------------------------
# Launch Functions
#------------------------------------------------------------------------------

launch_code() {
    local path="$1"
    local name="$2"

    echo -e "${DIM}  â†’ VS Code${NC}"
    code --new-window "$path" &
}

launch_claude() {
    local path="$1"
    local name="$2"
    local db_url="$3"
    local tools_path="$4"
    local count="${5:-1}"
    local skip_agent="${6:-false}"
    local auto_mode="${7:-false}"

    # Build environment
    local env_vars="PATH=$PATH:$tools_path:$path/.claude/tools"
    env_vars="$env_vars AGENT_MAIL_URL=http://localhost:8765"
    [[ -n "$db_url" ]] && env_vars="$env_vars DATABASE_URL=$db_url"

    # Get claude flags from config
    local claude_flags
    claude_flags=$(jq -r '.defaults.claude_flags // "--dangerously-skip-permissions"' "$CONFIG_FILE")

    # Build initial prompt (without -p flag which makes it non-interactive)
    local initial_prompt=""
    if [[ "$skip_agent" != "true" ]]; then
        if [[ "$auto_mode" == "true" ]]; then
            initial_prompt="/jat:start auto"
        else
            initial_prompt="/jat:start"
        fi
    fi

    # Launch N Claude sessions with staggered timing
    for ((i=1; i<=count; i++)); do
        local window_title
        if [[ $count -eq 1 ]]; then
            window_title="$name: Claude"
            echo -e "${DIM}  â†’ Claude Code${NC}"
        else
            window_title="$name: Claude #$i"
            echo -e "${DIM}  â†’ Claude Code #$i${NC}"
        fi

        $TERMINAL -T "$window_title" -e bash -c "cd '$path' && $env_vars claude $claude_flags '$initial_prompt'" &

        # Stagger launches so each agent sees previous agents' reservations
        if [[ $i -lt $count ]]; then
            local stagger
            stagger=$(jq -r '.defaults.agent_stagger // 15' "$CONFIG_FILE")
            sleep "$stagger"
        fi
    done
}

launch_npm() {
    local path="$1"
    local name="$2"
    local port="$3"

    if [[ -z "$port" ]]; then
        echo -e "${YELLOW}  âŠ˜ No dev server port configured${NC}"
        return 0
    fi

    echo -e "${DIM}  â†’ Dev Server :$port${NC}"
    $TERMINAL -T "$name: Dev Server :$port" -e bash -c "cd '$path' && npm run dev -- --port $port; exec bash" &
}

launch_browser() {
    local port="$1"
    local name="$2"

    if [[ -z "$port" ]]; then
        echo -e "${YELLOW}  âŠ˜ No port configured for browser${NC}"
        return 0
    fi

    echo -e "${DIM}  â†’ Browser http://localhost:$port${NC}"

    # Wait for server to start
    (
        sleep 2
        if command -v xdg-open &>/dev/null; then
            xdg-open "http://localhost:$port" &>/dev/null
        elif command -v open &>/dev/null; then
            open "http://localhost:$port"
        fi
    ) &
}

launch_dashboard() {
    local name="$1"
    local dashboard_port="${2:-3333}"
    local dashboard_path="$HOME/code/jat/dashboard"

    # Check if dashboard directory exists
    if [[ ! -d "$dashboard_path" ]]; then
        echo -e "${YELLOW}  âŠ˜ Dashboard not found: $dashboard_path${NC}"
        return 0
    fi

    echo -e "${DIM}  â†’ Dashboard :$dashboard_port${NC}"

    # Launch dashboard dev server in a terminal
    $TERMINAL -T "$name: Dashboard :$dashboard_port" -e bash -c "cd '$dashboard_path' && npm run dev -- --port $dashboard_port; exec bash" &

    # Open browser after delay for server to start
    (
        sleep 3
        if command -v xdg-open &>/dev/null; then
            xdg-open "http://localhost:$dashboard_port" &>/dev/null
        elif command -v open &>/dev/null; then
            open "http://localhost:$dashboard_port"
        fi
    ) &
}

launch_project() {
    local project="$1"
    shift

    # Parse options
    local do_all=true
    local do_code=false
    local do_claude=false
    local do_npm=false
    local do_browser=false
    local do_dashboard=false
    local session_count=1
    local skip_agent=false
    local skip_dashboard=false
    local auto_mode=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --code|-c)       do_all=false; do_code=true ;;
            --claude|-l)     do_all=false; do_claude=true ;;
            --npm|-n)        do_all=false; do_npm=true ;;
            --browser|-b)    do_all=false; do_browser=true ;;
            --dashboard|-d)  do_all=false; do_dashboard=true ;;
            --all|-a)        do_all=true ;;
            --no-agent)      skip_agent=true ;;
            --no-dashboard)  skip_dashboard=true ;;
            --auto)          auto_mode=true ;;
            [0-9]*)          session_count="$1" ;;
            *) echo -e "${RED}Unknown option: $1${NC}"; return 1 ;;
        esac
        shift
    done

    # Get project config
    local config
    config=$(get_project_config "$project")

    if [[ -z "$config" ]]; then
        echo -e "${RED}Unknown project: $project${NC}"
        echo ""
        echo "Available projects:"
        list_projects | while read -r p; do
            echo "  â€¢ $p"
        done
        echo ""
        echo "Add a project with: jat init"
        return 1
    fi

    # Parse config
    local name path port db_url active_color inactive_color tools_path
    name=$(echo "$config" | jq -r '.name')
    path=$(echo "$config" | jq -r '.path' | sed "s|^~|$HOME|")
    port=$(echo "$config" | jq -r '.port // empty')
    db_url=$(echo "$config" | jq -r '.database_url // empty')
    active_color=$(echo "$config" | jq -r '.active_color // empty')
    inactive_color=$(echo "$config" | jq -r '.inactive_color // empty')
    tools_path=$(jq -r '.defaults.tools_path // "~/.local/bin"' "$CONFIG_FILE" | sed "s|^~|$HOME|")

    # Verify path exists
    if [[ ! -d "$path" ]]; then
        echo -e "${RED}Project path does not exist: $path${NC}"
        return 1
    fi

    echo ""
    echo -e "${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${BOLD}â•‘  ${CYAN}ðŸš€ Launching: ${name}${NC}${BOLD}                                        â•‘${NC}"
    echo -e "${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    echo -e "  ${DIM}Path:${NC} $path"
    [[ -n "$port" ]] && echo -e "  ${DIM}Port:${NC} $port"
    [[ -n "$active_color" ]] && echo -e "  ${DIM}Color:${NC} $active_color"
    [[ $session_count -gt 1 ]] && echo -e "  ${DIM}Sessions:${NC} $session_count"
    echo ""

    # Launch components
    # Order: npm/browser/dashboard first (need time to start), then Claude sessions last
    if $do_all; then
        launch_code "$path" "$name"
        sleep 0.3
        launch_npm "$path" "$name" "$port"
        launch_browser "$port" "$name"
        # Launch dashboard unless --no-dashboard was specified
        if [[ "$skip_dashboard" != "true" ]]; then
            sleep 0.3
            launch_dashboard "$name"
        fi
        # Launch Claude sessions last (gives servers time to start)
        sleep 0.3
        launch_claude "$path" "$name" "$db_url" "$tools_path" "$session_count" "$skip_agent" "$auto_mode"
    else
        $do_code && launch_code "$path" "$name"
        $do_claude && launch_claude "$path" "$name" "$db_url" "$tools_path" "$session_count" "$skip_agent" "$auto_mode"
        $do_npm && launch_npm "$path" "$name" "$port"
        $do_browser && launch_browser "$port" "$name"
        $do_dashboard && launch_dashboard "$name"
    fi

    # Apply Hyprland colors
    if [[ -n "$active_color" ]]; then
        (sleep 1.5 && apply_border_color "$name:" "$active_color" "$inactive_color") &
    fi

    echo ""
    echo -e "${GREEN}âœ“ Environment launched${NC}"
}

#------------------------------------------------------------------------------
# Init / Setup
#------------------------------------------------------------------------------

init_projects() {
    echo -e "${BOLD}Scanning ~/code for projects...${NC}"
    echo ""

    local code_dir="$HOME/code"
    local added=0

    for repo_dir in "$code_dir"/*; do
        [[ ! -d "$repo_dir" ]] && continue
        [[ ! -d "$repo_dir/.git" ]] && continue

        local repo_name
        repo_name=$(basename "$repo_dir")

        # Check if already configured
        if [[ -n "$(get_project_config "$repo_name")" ]]; then
            echo -e "  ${DIM}âœ“ $repo_name (already configured)${NC}"
            continue
        fi

        # Auto-detect port from package.json if exists
        local port=""
        if [[ -f "$repo_dir/package.json" ]]; then
            # Try to find a port in scripts
            port=$(jq -r '.scripts.dev // ""' "$repo_dir/package.json" 2>/dev/null | grep -oE -- '--port[= ]+[0-9]+' | grep -oE '[0-9]+' | head -1 || true)
        fi

        # Generate a color based on repo name hash
        local hash
        hash=$(echo -n "$repo_name" | md5sum | cut -c1-6)
        local r=$((16#${hash:0:2}))
        local g=$((16#${hash:2:2}))
        local b=$((16#${hash:4:2}))
        local active_color="rgb($(printf '%02x%02x%02x' $r $g $b))"
        local inactive_color="rgb($(printf '%02x%02x%02x' $((r*3/4)) $((g*3/4)) $((b*3/4))))"

        # Add to config
        local new_project
        new_project=$(cat << EOF
{
  "name": "${repo_name^^}",
  "path": "~/code/$repo_name",
  "port": ${port:-null},
  "database_url": null,
  "active_color": "$active_color",
  "inactive_color": "$inactive_color"
}
EOF
)

        # Update config file
        local tmp_file
        tmp_file=$(mktemp)
        jq ".projects[\"$repo_name\"] = $new_project" "$CONFIG_FILE" > "$tmp_file"
        mv "$tmp_file" "$CONFIG_FILE"

        echo -e "  ${GREEN}+ $repo_name${NC}"
        added=$((added + 1))
    done

    echo ""
    if [[ $added -gt 0 ]]; then
        echo -e "${GREEN}Added $added project(s) to config${NC}"
    else
        echo -e "${DIM}No new projects found${NC}"
    fi
    echo ""
    echo "Edit config: $CONFIG_FILE"
}

show_config() {
    local project="$1"

    if [[ -z "$project" ]]; then
        # Show all config
        cat "$CONFIG_FILE" | jq .
    else
        local config
        config=$(get_project_config "$project")
        if [[ -z "$config" ]]; then
            echo -e "${RED}Unknown project: $project${NC}"
            return 1
        fi
        echo "$config" | jq .
    fi
}

edit_config() {
    ${EDITOR:-vim} "$CONFIG_FILE"
}

#------------------------------------------------------------------------------
# List Projects - Helper Functions
#------------------------------------------------------------------------------

# Get task counts from Beads for a project path
get_project_tasks() {
    local project_path="$1"
    local beads_dir="$project_path/.beads"

    if [[ ! -d "$beads_dir" ]]; then
        echo "-"
        return
    fi

    # Count open and total tasks
    local total open
    total=$(find "$beads_dir" -name "*.json" -type f 2>/dev/null | wc -l)
    open=$(grep -l '"status": "open"\|"status": "in_progress"' "$beads_dir"/*.json 2>/dev/null | wc -l)

    if [[ "$total" -eq 0 ]]; then
        echo "-"
    else
        echo "${open}/${total}"
    fi
}

# Get count of active/total agents for a project
# Returns: "2/67" (2 active, 67 total) or "67" (all inactive) or "-" (none)
get_project_agents() {
    local project_path="$1"
    local claude_dir="$project_path/.claude"

    if [[ ! -d "$claude_dir" ]]; then
        echo "-"
        return
    fi

    # Count total agent files
    local total=0
    local active=0

    for agent_file in "$claude_dir"/agent-*.txt; do
        [[ ! -f "$agent_file" ]] && continue
        total=$((total + 1))

        # Check if agent is active (file modified in last 30 minutes)
        local mtime now diff
        mtime=$(stat -c %Y "$agent_file" 2>/dev/null || stat -f %m "$agent_file" 2>/dev/null)
        now=$(date +%s)
        diff=$((now - mtime))

        if [[ $diff -lt 1800 ]]; then  # 30 minutes
            active=$((active + 1))
        fi
    done

    if [[ $total -eq 0 ]]; then
        echo "-"
    elif [[ $active -gt 0 ]]; then
        echo "${active}/${total}"
    else
        echo "$total"
    fi
}

# Check if a port is in use (server running)
get_port_status() {
    local port="$1"

    if [[ -z "$port" ]] || [[ "$port" == "null" ]]; then
        echo "-"
        return
    fi

    # Check if port is listening
    if ss -tlnp 2>/dev/null | grep -q ":${port} " || \
       lsof -i ":${port}" -sTCP:LISTEN >/dev/null 2>&1; then
        echo -e "${GREEN}running${NC}"
    else
        echo "-"
    fi
}

# Get time since last activity in a project (returns timestamp and human readable)
# Usage: get_last_activity path [format]
#   format: "human" (default) returns "3m", "2h", etc.
#   format: "timestamp" returns unix timestamp for sorting
get_last_activity() {
    local project_path="$1"
    local format="${2:-human}"

    if [[ ! -d "$project_path" ]]; then
        [[ "$format" == "timestamp" ]] && echo "0" || echo "-"
        return
    fi

    # Get most recent modification time from git or files
    local last_mod
    if [[ -d "$project_path/.git" ]]; then
        # Use git log for last commit time
        last_mod=$(git -C "$project_path" log -1 --format="%ct" 2>/dev/null)
    fi

    if [[ -z "$last_mod" ]]; then
        # Fall back to directory mtime
        last_mod=$(stat -c %Y "$project_path" 2>/dev/null || stat -f %m "$project_path" 2>/dev/null)
    fi

    if [[ -z "$last_mod" ]]; then
        [[ "$format" == "timestamp" ]] && echo "0" || echo "-"
        return
    fi

    # Return timestamp for sorting
    if [[ "$format" == "timestamp" ]]; then
        echo "$last_mod"
        return
    fi

    # Format as human readable
    local now diff
    now=$(date +%s)
    diff=$((now - last_mod))

    if [[ $diff -lt 60 ]]; then
        echo "now"
    elif [[ $diff -lt 3600 ]]; then
        echo "$((diff / 60))m"
    elif [[ $diff -lt 86400 ]]; then
        echo "$((diff / 3600))h"
    else
        echo "$((diff / 86400))d"
    fi
}

# Truncate path for display
truncate_path() {
    local path="$1"
    local max_len="${2:-25}"

    # Replace $HOME with ~
    path="${path/#$HOME/\~}"

    if [[ ${#path} -le $max_len ]]; then
        echo "$path"
    else
        echo "...${path: -$((max_len - 3))}"
    fi
}

#------------------------------------------------------------------------------
# List Projects
#------------------------------------------------------------------------------

list_all() {
    ensure_config

    echo ""
    echo -e "${BOLD}Configured Projects:${NC}"
    echo ""

    local projects
    projects=$(list_projects)

    if [[ -z "$projects" ]]; then
        echo -e "  ${DIM}No projects configured${NC}"
        echo ""
        echo "  Run: jat init"
        return 0
    fi

    # Table header
    printf "  ${DIM}%-12s %-6s %-8s %-7s %-8s %-6s %-25s${NC}\n" \
        "PROJECT" "PORT" "TASKS" "AGENTS" "STATUS" "LAST" "PATH"
    printf "  ${DIM}%-12s %-6s %-8s %-7s %-8s %-6s %-25s${NC}\n" \
        "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€" "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

    # Collect project data with timestamps for sorting
    local project_data=""
    for project in $projects; do
        local config
        config=$(get_project_config "$project")

        local port path timestamp
        port=$(echo "$config" | jq -r '.port // empty')
        path=$(echo "$config" | jq -r '.path' | sed "s|^~|$HOME|")
        timestamp=$(get_last_activity "$path" "timestamp")

        # Store as: timestamp|project|port|path
        project_data+="${timestamp}|${project}|${port}|${path}"$'\n'
    done

    # Sort by timestamp descending (most recent first) and display
    echo "$project_data" | sort -t'|' -k1 -nr | while IFS='|' read -r timestamp project port path; do
        [[ -z "$project" ]] && continue

        local tasks agents status last_activity display_path
        tasks=$(get_project_tasks "$path")
        agents=$(get_project_agents "$path")
        status=$(get_port_status "$port")
        last_activity=$(get_last_activity "$path")
        display_path=$(truncate_path "$path" 25)

        # Format port display
        local port_display="${port:-"-"}"
        [[ "$port_display" == "null" ]] && port_display="-"

        printf "  %-12s %-6s %-8s %-7s %-8b %-6s %-25s\n" \
            "$project" "$port_display" "$tasks" "$agents" "$status" "$last_activity" "$display_path"
    done

    echo ""
    echo -e "${DIM}Usage: jat <project> [N] [--code|--claude|--npm|--browser|--no-agent]${NC}"
    echo ""
}

#------------------------------------------------------------------------------
# Help
#------------------------------------------------------------------------------

show_help() {
    cat << 'EOF'

JAT CLI - Launch complete dev environments

USAGE:
    jat <project>              Launch full environment (VS Code + Claude + npm + browser + dashboard)
    jat <project> [N]          Launch with N Claude Code sessions (default: 1)
    jat <project> [N] --auto   Launch N agents that auto-attack the backlog
    jat <project> --claude     Launch only Claude Code
    jat <project> --code       Launch only VS Code
    jat <project> --npm        Launch only dev server
    jat <project> --browser    Open browser to dev server
    jat <project> --dashboard  Launch only JAT dashboard

COMMANDS:
    jat list                   Show all configured projects
    jat init                   Auto-detect projects in ~/code
    jat config [project]       Show config (all or specific project)
    jat edit                   Edit config file
    jat colors                 Recolor all Hyprland windows
    jat cleanup [--dry-run]    Delete stale agent session files
    jat hooks [path]           Install git hooks to repo (default: current dir)

OPTIONS:
    N               Number of Claude Code sessions to launch (1-10)
    --auto          Auto-attack mode: each agent picks highest priority task automatically
    --no-agent      Skip /agent:start prompt (raw Claude without auto-registration)
    --no-dashboard  Skip JAT dashboard (launch project only)
    -c, --code      Launch VS Code only
    -l, --claude    Launch Claude Code only
    -n, --npm       Launch npm dev server only
    -b, --browser   Open browser only
    -d, --dashboard Launch JAT dashboard only
    -a, --all       Launch everything (default, includes dashboard)

EXAMPLES:
    jat chimaro                # Full environment (1 Claude session + dashboard)
    jat chimaro 4              # Full environment with 4 Claude sessions
    jat chimaro 4 --auto       # Launch 4 agents that auto-attack the backlog!
    jat chimaro 4 --claude     # Only 4 Claude sessions (no VS Code/npm)
    jat chimaro --no-agent     # Claude without /agent:start auto-registration
    jat chimaro --no-dashboard # Full environment without dashboard
    jat chimaro --dashboard    # Launch only the JAT dashboard
    jat jat --code --npm       # VS Code + dev server
    jat init                   # Scan ~/code for projects

CONFIG:
    ~/.config/jat/projects.json

EOF
}

#------------------------------------------------------------------------------
# Cleanup Stale Agents
#------------------------------------------------------------------------------

cleanup_agents() {
    local dry_run=false
    [[ "$1" == "--dry-run" ]] && dry_run=true

    echo ""
    echo -e "${BOLD}Cleaning up stale agents...${NC}"
    echo ""

    local total_session_deleted=0
    local total_session_kept=0

    # =========================================================================
    # PART 1: Clean up session files (.claude/agent-*.txt)
    # =========================================================================
    echo -e "${DIM}Session files:${NC}"

    # Process each project
    for project in $(list_projects); do
        local config path claude_dir
        config=$(get_project_config "$project")
        path=$(echo "$config" | jq -r '.path' | sed "s|^~|$HOME|")
        claude_dir="$path/.claude"

        [[ ! -d "$claude_dir" ]] && continue

        local project_deleted=0
        local project_kept=0

        for agent_file in "$claude_dir"/agent-*.txt; do
            [[ ! -f "$agent_file" ]] && continue

            local agent_name session_id
            agent_name=$(cat "$agent_file" 2>/dev/null)
            session_id=$(basename "$agent_file" .txt | sed 's/agent-//')

            # Check if agent should be kept
            local keep=false
            local keep_reason=""

            # Check 1: Is the agent active (file modified in last 30 min)?
            local mtime now diff
            mtime=$(stat -c %Y "$agent_file" 2>/dev/null || stat -f %m "$agent_file" 2>/dev/null)
            now=$(date +%s)
            diff=$((now - mtime))
            if [[ $diff -lt 1800 ]]; then
                keep=true
                keep_reason="active session"
            fi

            # Check 2: Does the agent have ANY messages ever? (message history)
            if [[ "$keep" == "false" ]] && [[ -f "$db_path" ]]; then
                local agent_id_lookup message_count
                agent_id_lookup=$(sqlite3 "$db_path" "SELECT id FROM agents WHERE name = '$agent_name'" 2>/dev/null)
                if [[ -n "$agent_id_lookup" ]]; then
                    message_count=$(sqlite3 "$db_path" "SELECT COUNT(*) FROM message_recipients WHERE agent_id = $agent_id_lookup" 2>/dev/null || echo "0")
                    if [[ "$message_count" -gt 0 ]]; then
                        keep=true
                        keep_reason="has message history ($message_count messages)"
                    fi
                fi
            fi

            # Check 3: Does the agent have ANY tasks ever assigned in Beads? (task history)
            if [[ "$keep" == "false" ]] && command -v bd &>/dev/null; then
                local task_history
                task_history=$(bd list --json 2>/dev/null | jq -r --arg agent "$agent_name" \
                    '[.[] | select(.assignee == $agent)] | length' 2>/dev/null || echo "0")
                if [[ "$task_history" -gt 0 ]]; then
                    keep=true
                    keep_reason="has task history ($task_history tasks)"
                fi
            fi

            # Check 4: Does the agent have file reservations?
            if [[ "$keep" == "false" ]] && command -v am-reservations &>/dev/null; then
                local reservation_count
                reservation_count=$(am-reservations --agent "$agent_name" --json 2>/dev/null | jq 'length' 2>/dev/null || echo "0")
                if [[ "$reservation_count" -gt 0 ]]; then
                    keep=true
                    keep_reason="has $reservation_count file reservation(s)"
                fi
            fi

            if [[ "$keep" == "true" ]]; then
                project_kept=$((project_kept + 1))
                total_session_kept=$((total_session_kept + 1))
                if $dry_run; then
                    echo -e "  ${GREEN}[preserved]${NC} $agent_name - $keep_reason"
                fi
            else
                project_deleted=$((project_deleted + 1))
                total_session_deleted=$((total_session_deleted + 1))
                if $dry_run; then
                    echo -e "  ${YELLOW}[orphan]${NC} $agent_name - stale session file"
                else
                    rm -f "$agent_file"
                    echo -e "  ${RED}deleted${NC} $agent_name"
                fi
            fi
        done

        if [[ $project_deleted -gt 0 ]] || [[ $project_kept -gt 0 ]]; then
            if $dry_run; then
                echo -e "  ${DIM}$project: $project_deleted to delete, $project_kept to keep${NC}"
            fi
        fi
    done

    # =========================================================================
    # PART 2: Clean up Agent Mail database (~/.agent-mail.db)
    # =========================================================================
    echo ""
    echo -e "${DIM}Agent Mail database:${NC}"

    local db_path="$HOME/.agent-mail.db"
    local total_db_deleted=0
    local total_db_kept=0


    if [[ ! -f "$db_path" ]]; then
        echo -e "  ${DIM}No Agent Mail database found${NC}"
    else
        # Get all agents from Agent Mail database
        local agents_json
        agents_json=$(sqlite3 -json "$db_path" "SELECT id, name FROM agents ORDER BY name" 2>/dev/null)

        if [[ -z "$agents_json" ]] || [[ "$agents_json" == "[]" ]]; then
            echo -e "  ${DIM}No agents in database${NC}"
        else
            # Cache Beads tasks list once (avoid repeated calls)
            local beads_tasks=""
            if command -v bd &>/dev/null; then
                beads_tasks=$(bd list --json 2>/dev/null || echo "[]")
            fi

            # Cache session files list
            local session_agents=""
            for project in $(list_projects); do
                local config path
                config=$(get_project_config "$project")
                path=$(echo "$config" | jq -r '.path' | sed "s|^~|$HOME|")
                if [[ -d "$path/.claude" ]]; then
                    for f in "$path/.claude"/agent-*.txt; do
                        [[ -f "$f" ]] && session_agents+="$(cat "$f" 2>/dev/null)"$'\n'
                    done
                fi
            done

            # Process each agent using a for loop to avoid subshell issues
            local agent_ids agent_names
            agent_ids=$(echo "$agents_json" | jq -r '.[].id')
            agent_names=$(echo "$agents_json" | jq -r '.[].name')

            # Convert to arrays
            local -a ids=()
            local -a names=()
            while IFS= read -r id; do ids+=("$id"); done <<< "$agent_ids"
            while IFS= read -r name; do names+=("$name"); done <<< "$agent_names"

            local i
            for ((i=0; i<${#ids[@]}; i++)); do
                local agent_id="${ids[$i]}"
                local agent_name="${names[$i]}"

                [[ -z "$agent_id" ]] && continue
                [[ -z "$agent_name" ]] && continue

                # Check if agent should be kept
                local keep=false
                local keep_reason=""

                # Check 1: Does the agent have a session file anywhere? (active session)
                if [[ -n "$session_agents" ]] && echo "$session_agents" | grep -qF "$agent_name"; then
                    keep=true
                    keep_reason="active session"
                fi

                # Check 2: Does the agent have ANY messages ever? (message history)
                if [[ "$keep" == "false" ]]; then
                    local message_count
                    message_count=$(sqlite3 "$db_path" "SELECT COUNT(*) FROM message_recipients WHERE agent_id = $agent_id" 2>/dev/null || echo "0")
                    if [[ "$message_count" -gt 0 ]]; then
                        keep=true
                        keep_reason="has message history ($message_count messages)"
                    fi
                fi

                # Check 3: Does the agent have ANY tasks ever assigned in Beads? (task history)
                if [[ "$keep" == "false" ]] && [[ -n "$beads_tasks" ]] && [[ "$beads_tasks" != "[]" ]]; then
                    local task_history
                    task_history=$(echo "$beads_tasks" | jq -r --arg agent "$agent_name" \
                        '[.[] | select(.assignee == $agent)] | length' 2>/dev/null || echo "0")
                    if [[ "$task_history" -gt 0 ]]; then
                        keep=true
                        keep_reason="has task history ($task_history tasks)"
                    fi
                fi

                # Check 4: Does the agent have active file reservations?
                if [[ "$keep" == "false" ]]; then
                    local active_reservations
                    active_reservations=$(sqlite3 "$db_path" "SELECT COUNT(*) FROM file_reservations WHERE agent_id = $agent_id AND released_ts IS NULL AND expires_ts > datetime('now')" 2>/dev/null || echo "0")
                    if [[ "$active_reservations" -gt 0 ]]; then
                        keep=true
                        keep_reason="has $active_reservations active reservation(s)"
                    fi
                fi

                if [[ "$keep" == "true" ]]; then
                    total_db_kept=$((total_db_kept + 1))
                    if $dry_run; then
                        echo -e "  ${GREEN}[preserved]${NC} $agent_name - $keep_reason"
                    fi
                else
                    total_db_deleted=$((total_db_deleted + 1))
                    if $dry_run; then
                        echo -e "  ${YELLOW}[orphan]${NC} $agent_name - no session, no messages, no tasks"
                    else
                        # Delete agent and related records from Agent Mail database
                        sqlite3 "$db_path" "DELETE FROM message_recipients WHERE agent_id = $agent_id" 2>/dev/null
                        sqlite3 "$db_path" "DELETE FROM file_reservations WHERE agent_id = $agent_id" 2>/dev/null
                        sqlite3 "$db_path" "DELETE FROM agents WHERE id = $agent_id" 2>/dev/null
                        echo -e "  ${RED}deleted${NC} $agent_name"
                    fi
                fi
            done
        fi
    fi


    # =========================================================================
    # Summary
    # =========================================================================
    echo ""
    if $dry_run; then
        echo -e "${YELLOW}DRY RUN:${NC}"
        echo -e "  Session files: Would delete $total_session_deleted, keep $total_session_kept"
        echo -e "  Agent Mail DB: Would delete $total_db_deleted, keep $total_db_kept"
        echo ""
        echo "Run 'jat cleanup' to actually delete stale agents"
    else
        echo -e "${GREEN}Cleanup complete:${NC}"
        echo -e "  Session files: Deleted $total_session_deleted, kept $total_session_kept"
        echo -e "  Agent Mail DB: Deleted $total_db_deleted, kept $total_db_kept"
    fi
    echo ""
}

#------------------------------------------------------------------------------
# Install Git Hooks
#------------------------------------------------------------------------------

install_hooks() {
    local target="${1:-.}"

    # Resolve to absolute path
    target="$(cd "$target" 2>/dev/null && pwd)" || {
        echo -e "${RED}Error: Cannot access directory: $1${NC}" >&2
        return 1
    }

    # Check if target is a git repo
    if [[ ! -d "$target/.git" ]]; then
        echo -e "${RED}Error: Not a git repository: $target${NC}" >&2
        return 1
    fi

    local hooks_source="$HOME/code/jat/scripts/hooks"
    local hooks_target="$target/.git/hooks"

    if [[ ! -d "$hooks_source" ]]; then
        echo -e "${RED}Error: JAT hooks not found at $hooks_source${NC}" >&2
        return 1
    fi

    echo ""
    echo -e "${BOLD}Installing JAT git hooks to: $target${NC}"
    echo ""

    # Install pre-commit hook
    if [[ -f "$hooks_target/pre-commit" ]]; then
        # Check if it's already our hook
        if grep -q "AGENT REGISTRATION CHECK" "$hooks_target/pre-commit" 2>/dev/null; then
            echo -e "  ${GREEN}âœ“${NC} pre-commit hook already installed (updating)"
        else
            echo -e "  ${YELLOW}âš ${NC} Existing pre-commit hook found, backing up to pre-commit.backup"
            cp "$hooks_target/pre-commit" "$hooks_target/pre-commit.backup"
        fi
    fi

    cp "$hooks_source/pre-commit" "$hooks_target/pre-commit"
    chmod +x "$hooks_target/pre-commit"
    echo -e "  ${GREEN}âœ“${NC} Installed pre-commit hook"

    echo ""
    echo -e "${GREEN}âœ“ JAT hooks installed!${NC}"
    echo ""
    echo "The pre-commit hook will:"
    echo "  â€¢ Block commits if no agent is registered (run /jat:start first)"
    echo "  â€¢ Auto-sync beads changes before commit"
    echo ""
    echo "To bypass: git commit --no-verify"
    echo ""
}

#------------------------------------------------------------------------------
# Main
#------------------------------------------------------------------------------

main() {
    ensure_config

    if [[ $# -eq 0 ]]; then
        show_help
        exit 0
    fi

    local cmd="$1"
    shift

    case "$cmd" in
        help|--help|-h)
            show_help
            ;;
        list|ls)
            list_all
            ;;
        init)
            init_projects
            ;;
        config)
            show_config "$@"
            ;;
        edit)
            edit_config
            ;;
        colors)
            apply_all_colors
            ;;
        cleanup)
            cleanup_agents "$@"
            ;;
        hooks)
            install_hooks "$@"
            ;;
        *)
            # Assume it's a project name
            launch_project "$cmd" "$@"
            ;;
    esac
}

main "$@"
